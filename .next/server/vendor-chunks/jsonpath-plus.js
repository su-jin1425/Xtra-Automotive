"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsonpath-plus";
exports.ids = ["vendor-chunks/jsonpath-plus"];
exports.modules = {

/***/ "(ssr)/./node_modules/jsonpath-plus/dist/index-node-esm.mjs":
/*!************************************************************!*\
  !*** ./node_modules/jsonpath-plus/dist/index-node-esm.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONPath: () => (/* binding */ JSONPath)\n/* harmony export */ });\n/* harmony import */ var vm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vm */ \"vm\");\n\n\nconst {\n  hasOwnProperty: hasOwnProp\n} = Object.prototype;\n/**\n* @typedef {null|boolean|number|string|PlainObject|GenericArray} JSONObject\n*/\n\n/**\n * Copies array and then pushes item into it.\n * @param {GenericArray} arr Array to copy and into which to push\n * @param {any} item Array item to add (to end)\n * @returns {GenericArray} Copy of the original array\n */\n\nfunction push(arr, item) {\n  arr = arr.slice();\n  arr.push(item);\n  return arr;\n}\n/**\n * Copies array and then unshifts item into it.\n * @param {any} item Array item to add (to beginning)\n * @param {GenericArray} arr Array to copy and into which to unshift\n * @returns {GenericArray} Copy of the original array\n */\n\n\nfunction unshift(item, arr) {\n  arr = arr.slice();\n  arr.unshift(item);\n  return arr;\n}\n/**\n * Caught when JSONPath is used without `new` but rethrown if with `new`\n * @extends Error\n */\n\n\nclass NewError extends Error {\n  /**\n   * @param {any} value The evaluated scalar value\n   */\n  constructor(value) {\n    super('JSONPath should not be called with \"new\" (it prevents return ' + 'of (unwrapped) scalar values)');\n    this.avoidNew = true;\n    this.value = value;\n    this.name = 'NewError';\n  }\n\n}\n/**\n* @typedef {PlainObject} ReturnObject\n* @property {string} path\n* @property {JSONObject} value\n* @property {PlainObject|GenericArray} parent\n* @property {string} parentProperty\n*/\n\n/**\n* @callback JSONPathCallback\n* @param {string|PlainObject} preferredOutput\n* @param {\"value\"|\"property\"} type\n* @param {ReturnObject} fullRetObj\n* @returns {void}\n*/\n\n/**\n* @callback OtherTypeCallback\n* @param {JSONObject} val\n* @param {string} path\n* @param {PlainObject|GenericArray} parent\n* @param {string} parentPropName\n* @returns {boolean}\n*/\n\n/* eslint-disable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */\n\n/**\n * @typedef {PlainObject} JSONPathOptions\n * @property {JSON} json\n * @property {string|string[]} path\n * @property {\"value\"|\"path\"|\"pointer\"|\"parent\"|\"parentProperty\"|\"all\"} [resultType=\"value\"]\n * @property {boolean} [flatten=false]\n * @property {boolean} [wrap=true]\n * @property {PlainObject} [sandbox={}]\n * @property {boolean} [preventEval=false]\n * @property {PlainObject|GenericArray|null} [parent=null]\n * @property {string|null} [parentProperty=null]\n * @property {JSONPathCallback} [callback]\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\n *   function which throws on encountering `@other`\n * @property {boolean} [autostart=true]\n */\n\n/* eslint-enable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */\n\n/**\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\n * @param {string} [expr] JSON path to evaluate\n * @param {JSON} [obj] JSON object to evaluate against\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\n *     per `resultType`, 2) `\"value\"|\"property\"`, 3) Full returned object with\n *     all payloads\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\n *   of one's query, this will be invoked with the value of the item, its\n *   path, its parent, and its parent's property name, and it should return\n *   a boolean indicating whether the supplied value belongs to the \"other\"\n *   type or not (or it may handle transformations and return `false`).\n * @returns {JSONPath}\n * @class\n */\n\n\nfunction JSONPath(opts, expr, obj, callback, otherTypeCallback) {\n  // eslint-disable-next-line no-restricted-syntax\n  if (!(this instanceof JSONPath)) {\n    try {\n      return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\n    } catch (e) {\n      if (!e.avoidNew) {\n        throw e;\n      }\n\n      return e.value;\n    }\n  }\n\n  if (typeof opts === 'string') {\n    otherTypeCallback = callback;\n    callback = obj;\n    obj = expr;\n    expr = opts;\n    opts = null;\n  }\n\n  const optObj = opts && typeof opts === 'object';\n  opts = opts || {};\n  this.json = opts.json || obj;\n  this.path = opts.path || expr;\n  this.resultType = opts.resultType || 'value';\n  this.flatten = opts.flatten || false;\n  this.wrap = hasOwnProp.call(opts, 'wrap') ? opts.wrap : true;\n  this.sandbox = opts.sandbox || {};\n  this.preventEval = opts.preventEval || false;\n  this.parent = opts.parent || null;\n  this.parentProperty = opts.parentProperty || null;\n  this.callback = opts.callback || callback || null;\n\n  this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {\n    throw new TypeError('You must supply an otherTypeCallback callback option ' + 'with the @other() operator.');\n  };\n\n  if (opts.autostart !== false) {\n    const args = {\n      path: optObj ? opts.path : expr\n    };\n\n    if (!optObj) {\n      args.json = obj;\n    } else if ('json' in opts) {\n      args.json = opts.json;\n    }\n\n    const ret = this.evaluate(args);\n\n    if (!ret || typeof ret !== 'object') {\n      throw new NewError(ret);\n    }\n\n    return ret;\n  }\n} // PUBLIC METHODS\n\n\nJSONPath.prototype.evaluate = function (expr, json, callback, otherTypeCallback) {\n  let currParent = this.parent,\n      currParentProperty = this.parentProperty;\n  let {\n    flatten,\n    wrap\n  } = this;\n  this.currResultType = this.resultType;\n  this.currPreventEval = this.preventEval;\n  this.currSandbox = this.sandbox;\n  callback = callback || this.callback;\n  this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\n  json = json || this.json;\n  expr = expr || this.path;\n\n  if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\n    if (!expr.path && expr.path !== '') {\n      throw new TypeError('You must supply a \"path\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n\n    if (!hasOwnProp.call(expr, 'json')) {\n      throw new TypeError('You must supply a \"json\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n\n    ({\n      json\n    } = expr);\n    flatten = hasOwnProp.call(expr, 'flatten') ? expr.flatten : flatten;\n    this.currResultType = hasOwnProp.call(expr, 'resultType') ? expr.resultType : this.currResultType;\n    this.currSandbox = hasOwnProp.call(expr, 'sandbox') ? expr.sandbox : this.currSandbox;\n    wrap = hasOwnProp.call(expr, 'wrap') ? expr.wrap : wrap;\n    this.currPreventEval = hasOwnProp.call(expr, 'preventEval') ? expr.preventEval : this.currPreventEval;\n    callback = hasOwnProp.call(expr, 'callback') ? expr.callback : callback;\n    this.currOtherTypeCallback = hasOwnProp.call(expr, 'otherTypeCallback') ? expr.otherTypeCallback : this.currOtherTypeCallback;\n    currParent = hasOwnProp.call(expr, 'parent') ? expr.parent : currParent;\n    currParentProperty = hasOwnProp.call(expr, 'parentProperty') ? expr.parentProperty : currParentProperty;\n    expr = expr.path;\n  }\n\n  currParent = currParent || null;\n  currParentProperty = currParentProperty || null;\n\n  if (Array.isArray(expr)) {\n    expr = JSONPath.toPathString(expr);\n  }\n\n  if (!expr && expr !== '' || !json) {\n    return undefined;\n  }\n\n  const exprList = JSONPath.toPathArray(expr);\n\n  if (exprList[0] === '$' && exprList.length > 1) {\n    exprList.shift();\n  }\n\n  this._hasParentSelector = null;\n\n  const result = this._trace(exprList, json, ['$'], currParent, currParentProperty, callback).filter(function (ea) {\n    return ea && !ea.isParentSelector;\n  });\n\n  if (!result.length) {\n    return wrap ? [] : undefined;\n  }\n\n  if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\n    return this._getPreferredOutput(result[0]);\n  }\n\n  return result.reduce((rslt, ea) => {\n    const valOrPath = this._getPreferredOutput(ea);\n\n    if (flatten && Array.isArray(valOrPath)) {\n      rslt = rslt.concat(valOrPath);\n    } else {\n      rslt.push(valOrPath);\n    }\n\n    return rslt;\n  }, []);\n}; // PRIVATE METHODS\n\n\nJSONPath.prototype._getPreferredOutput = function (ea) {\n  const resultType = this.currResultType;\n\n  switch (resultType) {\n    case 'all':\n      {\n        const path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);\n        ea.pointer = JSONPath.toPointer(path);\n        ea.path = typeof ea.path === 'string' ? ea.path : JSONPath.toPathString(ea.path);\n        return ea;\n      }\n\n    case 'value':\n    case 'parent':\n    case 'parentProperty':\n      return ea[resultType];\n\n    case 'path':\n      return JSONPath.toPathString(ea[resultType]);\n\n    case 'pointer':\n      return JSONPath.toPointer(ea.path);\n\n    default:\n      throw new TypeError('Unknown result type');\n  }\n};\n\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\n  if (callback) {\n    const preferredOutput = this._getPreferredOutput(fullRetObj);\n\n    fullRetObj.path = typeof fullRetObj.path === 'string' ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path); // eslint-disable-next-line node/callback-return\n\n    callback(preferredOutput, type, fullRetObj);\n  }\n};\n/**\n *\n * @param {string} expr\n * @param {JSONObject} val\n * @param {string} path\n * @param {PlainObject|GenericArray} parent\n * @param {string} parentPropName\n * @param {JSONPathCallback} callback\n * @param {boolean} hasArrExpr\n * @param {boolean} literalPriority\n * @returns {ReturnObject|ReturnObject[]}\n */\n\n\nJSONPath.prototype._trace = function (expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {\n  // No expr to follow? return path and value as the result of\n  //  this trace branch\n  let retObj;\n\n  if (!expr.length) {\n    retObj = {\n      path,\n      value: val,\n      parent,\n      parentProperty: parentPropName,\n      hasArrExpr\n    };\n\n    this._handleCallback(retObj, callback, 'value');\n\n    return retObj;\n  }\n\n  const loc = expr[0],\n        x = expr.slice(1); // We need to gather the return value of recursive trace calls in order to\n  // do the parent sel computation.\n\n  const ret = [];\n  /**\n   *\n   * @param {ReturnObject|ReturnObject[]} elems\n   * @returns {void}\n   */\n\n  function addRet(elems) {\n    if (Array.isArray(elems)) {\n      // This was causing excessive stack size in Node (with or\n      //  without Babel) against our performance test:\n      //  `ret.push(...elems);`\n      elems.forEach(t => {\n        ret.push(t);\n      });\n    } else {\n      ret.push(elems);\n    }\n  }\n\n  if ((typeof loc !== 'string' || literalPriority) && val && hasOwnProp.call(val, loc)) {\n    // simple case--directly follow property\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr)); // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\n  } else if (loc === '*') {\n    // all child properties\n    this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb) => {\n      addRet(this._trace(unshift(m, _x), v, p, par, pr, cb, true, true));\n    });\n  } else if (loc === '..') {\n    // all descendent parent properties\n    // Check remaining expression with val's immediate children\n    addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));\n\n    this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb) => {\n      // We don't join m and x here because we only want parents,\n      //   not scalar values\n      if (typeof v[m] === 'object') {\n        // Keep going with recursive descent on val's\n        //   object children\n        addRet(this._trace(unshift(l, _x), v[m], push(p, m), v, m, cb, true));\n      }\n    }); // The parent sel computation is handled in the frame above using the\n    // ancestor object of val\n\n  } else if (loc === '^') {\n    // This is not a final endpoint, so we do not invoke the callback here\n    this._hasParentSelector = true;\n    return {\n      path: path.slice(0, -1),\n      expr: x,\n      isParentSelector: true\n    };\n  } else if (loc === '~') {\n    // property name\n    retObj = {\n      path: push(path, loc),\n      value: parentPropName,\n      parent,\n      parentProperty: null\n    };\n\n    this._handleCallback(retObj, callback, 'property');\n\n    return retObj;\n  } else if (loc === '$') {\n    // root only\n    addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\n  } else if (/^(-?\\d*):(-?\\d*):?(\\d*)$/u.test(loc)) {\n    // [start:end:step]  Python slice syntax\n    addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));\n  } else if (loc.indexOf('?(') === 0) {\n    // [?(expr)] (filtering)\n    if (this.currPreventEval) {\n      throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\n    }\n\n    this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb) => {\n      if (this._eval(l.replace(/^\\?\\((.*?)\\)$/u, '$1'), v[m], m, p, par, pr)) {\n        addRet(this._trace(unshift(m, _x), v, p, par, pr, cb, true));\n      }\n    });\n  } else if (loc[0] === '(') {\n    // [(expr)] (dynamic property/index)\n    if (this.currPreventEval) {\n      throw new Error('Eval [(expr)] prevented in JSONPath expression.');\n    } // As this will resolve to a property name (but we don't know it\n    //  yet), property and parent information is relative to the\n    //  parent of the property to which this expression will resolve\n\n\n    addRet(this._trace(unshift(this._eval(loc, val, path[path.length - 1], path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));\n  } else if (loc[0] === '@') {\n    // value type: @boolean(), etc.\n    let addType = false;\n    const valueType = loc.slice(1, -2);\n\n    switch (valueType) {\n      case 'scalar':\n        if (!val || !['object', 'function'].includes(typeof val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'boolean':\n      case 'string':\n      case 'undefined':\n      case 'function':\n        // eslint-disable-next-line valid-typeof\n        if (typeof val === valueType) {\n          addType = true;\n        }\n\n        break;\n\n      case 'integer':\n        if (Number.isFinite(val) && !(val % 1)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'number':\n        if (Number.isFinite(val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'nonFinite':\n        if (typeof val === 'number' && !Number.isFinite(val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'object':\n        // eslint-disable-next-line valid-typeof\n        if (val && typeof val === valueType) {\n          addType = true;\n        }\n\n        break;\n\n      case 'array':\n        if (Array.isArray(val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'other':\n        addType = this.currOtherTypeCallback(val, path, parent, parentPropName);\n        break;\n\n      case 'null':\n        if (val === null) {\n          addType = true;\n        }\n\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new TypeError('Unknown value type ' + valueType);\n    }\n\n    if (addType) {\n      retObj = {\n        path,\n        value: val,\n        parent,\n        parentProperty: parentPropName\n      };\n\n      this._handleCallback(retObj, callback, 'value');\n\n      return retObj;\n    } // `-escaped property\n\n  } else if (loc[0] === '`' && val && hasOwnProp.call(val, loc.slice(1))) {\n    const locProp = loc.slice(1);\n    addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));\n  } else if (loc.includes(',')) {\n    // [name1,name2,...]\n    const parts = loc.split(',');\n\n    for (const part of parts) {\n      addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));\n    } // simple case--directly follow property\n\n  } else if (!literalPriority && val && hasOwnProp.call(val, loc)) {\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));\n  } // We check the resulting values for parent selections. For parent\n  // selections we discard the value object and continue the trace with the\n  // current val object\n\n\n  if (this._hasParentSelector) {\n    for (let t = 0; t < ret.length; t++) {\n      const rett = ret[t];\n\n      if (rett && rett.isParentSelector) {\n        const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);\n\n        if (Array.isArray(tmp)) {\n          ret[t] = tmp[0];\n          const tl = tmp.length;\n\n          for (let tt = 1; tt < tl; tt++) {\n            t++;\n            ret.splice(t, 0, tmp[tt]);\n          }\n        } else {\n          ret[t] = tmp;\n        }\n      }\n    }\n  }\n\n  return ret;\n};\n\nJSONPath.prototype._walk = function (loc, expr, val, path, parent, parentPropName, callback, f) {\n  if (Array.isArray(val)) {\n    const n = val.length;\n\n    for (let i = 0; i < n; i++) {\n      f(i, loc, expr, val, path, parent, parentPropName, callback);\n    }\n  } else if (val && typeof val === 'object') {\n    Object.keys(val).forEach(m => {\n      f(m, loc, expr, val, path, parent, parentPropName, callback);\n    });\n  }\n};\n\nJSONPath.prototype._slice = function (loc, expr, val, path, parent, parentPropName, callback) {\n  if (!Array.isArray(val)) {\n    return undefined;\n  }\n\n  const len = val.length,\n        parts = loc.split(':'),\n        step = parts[2] && Number.parseInt(parts[2]) || 1;\n  let start = parts[0] && Number.parseInt(parts[0]) || 0,\n      end = parts[1] && Number.parseInt(parts[1]) || len;\n  start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);\n  end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);\n  const ret = [];\n\n  for (let i = start; i < end; i += step) {\n    const tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true); // Should only be possible to be an array here since first part of\n    //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\n    //     nor begin with `@` (as could return objects)\n    // This was causing excessive stack size in Node (with or\n    //  without Babel) against our performance test: `ret.push(...tmp);`\n\n\n    tmp.forEach(t => {\n      ret.push(t);\n    });\n  }\n\n  return ret;\n};\n\nJSONPath.prototype._eval = function (code, _v, _vname, path, parent, parentPropName) {\n  if (code.includes('@parentProperty')) {\n    this.currSandbox._$_parentProperty = parentPropName;\n    code = code.replace(/@parentProperty/gu, '_$_parentProperty');\n  }\n\n  if (code.includes('@parent')) {\n    this.currSandbox._$_parent = parent;\n    code = code.replace(/@parent/gu, '_$_parent');\n  }\n\n  if (code.includes('@property')) {\n    this.currSandbox._$_property = _vname;\n    code = code.replace(/@property/gu, '_$_property');\n  }\n\n  if (code.includes('@path')) {\n    this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\n    code = code.replace(/@path/gu, '_$_path');\n  }\n\n  if (code.includes('@root')) {\n    this.currSandbox._$_root = this.json;\n    code = code.replace(/@root/gu, '_$_root');\n  }\n\n  if (/@([.\\s)[])/u.test(code)) {\n    this.currSandbox._$_v = _v;\n    code = code.replace(/@([.\\s)[])/gu, '_$_v$1');\n  }\n\n  try {\n    return this.vm.runInNewContext(code, this.currSandbox);\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.log(e);\n    throw new Error('jsonPath: ' + e.message + ': ' + code);\n  }\n}; // PUBLIC CLASS PROPERTIES AND METHODS\n// Could store the cache object itself\n\n\nJSONPath.cache = {};\n/**\n * @param {string[]} pathArr Array to convert\n * @returns {string} The path string\n */\n\nJSONPath.toPathString = function (pathArr) {\n  const x = pathArr,\n        n = x.length;\n  let p = '$';\n\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += /^[0-9*]+$/u.test(x[i]) ? '[' + x[i] + ']' : \"['\" + x[i] + \"']\";\n    }\n  }\n\n  return p;\n};\n/**\n * @param {string} pointer JSON Path\n * @returns {string} JSON Pointer\n */\n\n\nJSONPath.toPointer = function (pointer) {\n  const x = pointer,\n        n = x.length;\n  let p = '';\n\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += '/' + x[i].toString().replace(/~/gu, '~0').replace(/\\//gu, '~1');\n    }\n  }\n\n  return p;\n};\n/**\n * @param {string} expr Expression to convert\n * @returns {string[]}\n */\n\n\nJSONPath.toPathArray = function (expr) {\n  const {\n    cache\n  } = JSONPath;\n\n  if (cache[expr]) {\n    return cache[expr].concat();\n  }\n\n  const subx = [];\n  const normalized = expr // Properties\n  .replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu, ';$&;') // Parenthetical evaluations (filtering and otherwise), directly\n  //   within brackets or single quotes\n  .replace(/[['](\\??\\(.*?\\))[\\]']/gu, function ($0, $1) {\n    return '[#' + (subx.push($1) - 1) + ']';\n  }) // Escape periods and tildes within properties\n  .replace(/\\[['\"]([^'\\]]*)['\"]\\]/gu, function ($0, prop) {\n    return \"['\" + prop.replace(/\\./gu, '%@%').replace(/~/gu, '%%@@%%') + \"']\";\n  }) // Properties operator\n  .replace(/~/gu, ';~;') // Split by property boundaries\n  .replace(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu, ';') // Reinsert periods within properties\n  .replace(/%@%/gu, '.') // Reinsert tildes within properties\n  .replace(/%%@@%%/gu, '~') // Parent\n  .replace(/(?:;)?(\\^+)(?:;)?/gu, function ($0, ups) {\n    return ';' + ups.split('').join(';') + ';';\n  }) // Descendents\n  .replace(/;;;|;;/gu, ';..;') // Remove trailing\n  .replace(/;$|'?\\]|'$/gu, '');\n  const exprList = normalized.split(';').map(function (exp) {\n    const match = exp.match(/#(\\d+)/u);\n    return !match || !match[1] ? exp : subx[match[1]];\n  });\n  cache[expr] = exprList;\n  return cache[expr].concat();\n};\n\nJSONPath.prototype.vm = vm__WEBPACK_IMPORTED_MODULE_0__;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnBhdGgtcGx1cy9kaXN0L2luZGV4LW5vZGUtZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvQjs7QUFFcEI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLFlBQVkscURBQXFEO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGNBQWM7QUFDekIsYUFBYSxjQUFjO0FBQzNCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixhQUFhLFFBQVE7QUFDckIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsMEJBQTBCO0FBQ3ZDLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUIsVUFBVSxvQkFBb0I7QUFDOUIsVUFBVSxjQUFjO0FBQ3hCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsUUFBUTtBQUNsQixVQUFVLDBCQUEwQjtBQUNwQyxVQUFVLFFBQVE7QUFDbEIsWUFBWTtBQUNaOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWMsTUFBTTtBQUNwQixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLDBEQUEwRDtBQUN4RSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsYUFBYSxXQUFXO0FBQ3RDLGNBQWMsU0FBUztBQUN2QixjQUFjLCtCQUErQjtBQUM3QyxjQUFjLGFBQWE7QUFDM0IsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxtQkFB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFIQUFxSCxHQUFHO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILG9CQUFvQixFQUFFO0FBQ3RCLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsYUFBYSx5QkFBeUIsT0FBTztBQUM3QyxHQUFHO0FBQ0gsZUFBZSxHQUFHLE9BQU8sR0FBRztBQUM1QixhQUFhO0FBQ2Isc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwrQkFBRTs7QUFFTiIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21zdGFydGVyLy4vbm9kZV9tb2R1bGVzL2pzb25wYXRoLXBsdXMvZGlzdC9pbmRleC1ub2RlLWVzbS5tanM/ZTBmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdm0gZnJvbSAndm0nO1xuXG5jb25zdCB7XG4gIGhhc093blByb3BlcnR5OiBoYXNPd25Qcm9wXG59ID0gT2JqZWN0LnByb3RvdHlwZTtcbi8qKlxuKiBAdHlwZWRlZiB7bnVsbHxib29sZWFufG51bWJlcnxzdHJpbmd8UGxhaW5PYmplY3R8R2VuZXJpY0FycmF5fSBKU09OT2JqZWN0XG4qL1xuXG4vKipcbiAqIENvcGllcyBhcnJheSBhbmQgdGhlbiBwdXNoZXMgaXRlbSBpbnRvIGl0LlxuICogQHBhcmFtIHtHZW5lcmljQXJyYXl9IGFyciBBcnJheSB0byBjb3B5IGFuZCBpbnRvIHdoaWNoIHRvIHB1c2hcbiAqIEBwYXJhbSB7YW55fSBpdGVtIEFycmF5IGl0ZW0gdG8gYWRkICh0byBlbmQpXG4gKiBAcmV0dXJucyB7R2VuZXJpY0FycmF5fSBDb3B5IG9mIHRoZSBvcmlnaW5hbCBhcnJheVxuICovXG5cbmZ1bmN0aW9uIHB1c2goYXJyLCBpdGVtKSB7XG4gIGFyciA9IGFyci5zbGljZSgpO1xuICBhcnIucHVzaChpdGVtKTtcbiAgcmV0dXJuIGFycjtcbn1cbi8qKlxuICogQ29waWVzIGFycmF5IGFuZCB0aGVuIHVuc2hpZnRzIGl0ZW0gaW50byBpdC5cbiAqIEBwYXJhbSB7YW55fSBpdGVtIEFycmF5IGl0ZW0gdG8gYWRkICh0byBiZWdpbm5pbmcpXG4gKiBAcGFyYW0ge0dlbmVyaWNBcnJheX0gYXJyIEFycmF5IHRvIGNvcHkgYW5kIGludG8gd2hpY2ggdG8gdW5zaGlmdFxuICogQHJldHVybnMge0dlbmVyaWNBcnJheX0gQ29weSBvZiB0aGUgb3JpZ2luYWwgYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHVuc2hpZnQoaXRlbSwgYXJyKSB7XG4gIGFyciA9IGFyci5zbGljZSgpO1xuICBhcnIudW5zaGlmdChpdGVtKTtcbiAgcmV0dXJuIGFycjtcbn1cbi8qKlxuICogQ2F1Z2h0IHdoZW4gSlNPTlBhdGggaXMgdXNlZCB3aXRob3V0IGBuZXdgIGJ1dCByZXRocm93biBpZiB3aXRoIGBuZXdgXG4gKiBAZXh0ZW5kcyBFcnJvclxuICovXG5cblxuY2xhc3MgTmV3RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGV2YWx1YXRlZCBzY2FsYXIgdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoJ0pTT05QYXRoIHNob3VsZCBub3QgYmUgY2FsbGVkIHdpdGggXCJuZXdcIiAoaXQgcHJldmVudHMgcmV0dXJuICcgKyAnb2YgKHVud3JhcHBlZCkgc2NhbGFyIHZhbHVlcyknKTtcbiAgICB0aGlzLmF2b2lkTmV3ID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5uYW1lID0gJ05ld0Vycm9yJztcbiAgfVxuXG59XG4vKipcbiogQHR5cGVkZWYge1BsYWluT2JqZWN0fSBSZXR1cm5PYmplY3RcbiogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGhcbiogQHByb3BlcnR5IHtKU09OT2JqZWN0fSB2YWx1ZVxuKiBAcHJvcGVydHkge1BsYWluT2JqZWN0fEdlbmVyaWNBcnJheX0gcGFyZW50XG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXJlbnRQcm9wZXJ0eVxuKi9cblxuLyoqXG4qIEBjYWxsYmFjayBKU09OUGF0aENhbGxiYWNrXG4qIEBwYXJhbSB7c3RyaW5nfFBsYWluT2JqZWN0fSBwcmVmZXJyZWRPdXRwdXRcbiogQHBhcmFtIHtcInZhbHVlXCJ8XCJwcm9wZXJ0eVwifSB0eXBlXG4qIEBwYXJhbSB7UmV0dXJuT2JqZWN0fSBmdWxsUmV0T2JqXG4qIEByZXR1cm5zIHt2b2lkfVxuKi9cblxuLyoqXG4qIEBjYWxsYmFjayBPdGhlclR5cGVDYWxsYmFja1xuKiBAcGFyYW0ge0pTT05PYmplY3R9IHZhbFxuKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuKiBAcGFyYW0ge1BsYWluT2JqZWN0fEdlbmVyaWNBcnJheX0gcGFyZW50XG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRQcm9wTmFtZVxuKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gLS0gQ2FuIG1ha2UgbXVsdGlsaW5lIHR5cGUgYWZ0ZXIgaHR0cHM6Ly9naXRodWIuY29tL3N5YXZvcnNreS9jb21tZW50LXBhcnNlci9pc3N1ZXMvMTA5ICovXG5cbi8qKlxuICogQHR5cGVkZWYge1BsYWluT2JqZWN0fSBKU09OUGF0aE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7SlNPTn0ganNvblxuICogQHByb3BlcnR5IHtzdHJpbmd8c3RyaW5nW119IHBhdGhcbiAqIEBwcm9wZXJ0eSB7XCJ2YWx1ZVwifFwicGF0aFwifFwicG9pbnRlclwifFwicGFyZW50XCJ8XCJwYXJlbnRQcm9wZXJ0eVwifFwiYWxsXCJ9IFtyZXN1bHRUeXBlPVwidmFsdWVcIl1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZsYXR0ZW49ZmFsc2VdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwPXRydWVdXG4gKiBAcHJvcGVydHkge1BsYWluT2JqZWN0fSBbc2FuZGJveD17fV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ByZXZlbnRFdmFsPWZhbHNlXVxuICogQHByb3BlcnR5IHtQbGFpbk9iamVjdHxHZW5lcmljQXJyYXl8bnVsbH0gW3BhcmVudD1udWxsXVxuICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3BhcmVudFByb3BlcnR5PW51bGxdXG4gKiBAcHJvcGVydHkge0pTT05QYXRoQ2FsbGJhY2t9IFtjYWxsYmFja11cbiAqIEBwcm9wZXJ0eSB7T3RoZXJUeXBlQ2FsbGJhY2t9IFtvdGhlclR5cGVDYWxsYmFja10gRGVmYXVsdHMgdG9cbiAqICAgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIG9uIGVuY291bnRlcmluZyBgQG90aGVyYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b3N0YXJ0PXRydWVdXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuIC0tIENhbiBtYWtlIG11bHRpbGluZSB0eXBlIGFmdGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9zeWF2b3Jza3kvY29tbWVudC1wYXJzZXIvaXNzdWVzLzEwOSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEpTT05QYXRoT3B0aW9uc30gb3B0cyBJZiBhIHN0cmluZywgd2lsbCBiZSB0cmVhdGVkIGFzIGBleHByYFxuICogQHBhcmFtIHtzdHJpbmd9IFtleHByXSBKU09OIHBhdGggdG8gZXZhbHVhdGVcbiAqIEBwYXJhbSB7SlNPTn0gW29ial0gSlNPTiBvYmplY3QgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICogQHBhcmFtIHtKU09OUGF0aENhbGxiYWNrfSBbY2FsbGJhY2tdIFBhc3NlZCAzIGFyZ3VtZW50czogMSkgZGVzaXJlZCBwYXlsb2FkXG4gKiAgICAgcGVyIGByZXN1bHRUeXBlYCwgMikgYFwidmFsdWVcInxcInByb3BlcnR5XCJgLCAzKSBGdWxsIHJldHVybmVkIG9iamVjdCB3aXRoXG4gKiAgICAgYWxsIHBheWxvYWRzXG4gKiBAcGFyYW0ge090aGVyVHlwZUNhbGxiYWNrfSBbb3RoZXJUeXBlQ2FsbGJhY2tdIElmIGBAb3RoZXIoKWAgaXMgYXQgdGhlIGVuZFxuICogICBvZiBvbmUncyBxdWVyeSwgdGhpcyB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGl0ZW0sIGl0c1xuICogICBwYXRoLCBpdHMgcGFyZW50LCBhbmQgaXRzIHBhcmVudCdzIHByb3BlcnR5IG5hbWUsIGFuZCBpdCBzaG91bGQgcmV0dXJuXG4gKiAgIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN1cHBsaWVkIHZhbHVlIGJlbG9uZ3MgdG8gdGhlIFwib3RoZXJcIlxuICogICB0eXBlIG9yIG5vdCAob3IgaXQgbWF5IGhhbmRsZSB0cmFuc2Zvcm1hdGlvbnMgYW5kIHJldHVybiBgZmFsc2VgKS5cbiAqIEByZXR1cm5zIHtKU09OUGF0aH1cbiAqIEBjbGFzc1xuICovXG5cblxuZnVuY3Rpb24gSlNPTlBhdGgob3B0cywgZXhwciwgb2JqLCBjYWxsYmFjaywgb3RoZXJUeXBlQ2FsbGJhY2spIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBKU09OUGF0aCkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBKU09OUGF0aChvcHRzLCBleHByLCBvYmosIGNhbGxiYWNrLCBvdGhlclR5cGVDYWxsYmFjayk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFlLmF2b2lkTmV3KSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICBvdGhlclR5cGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gb2JqO1xuICAgIG9iaiA9IGV4cHI7XG4gICAgZXhwciA9IG9wdHM7XG4gICAgb3B0cyA9IG51bGw7XG4gIH1cblxuICBjb25zdCBvcHRPYmogPSBvcHRzICYmIHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JztcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuanNvbiA9IG9wdHMuanNvbiB8fCBvYmo7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aCB8fCBleHByO1xuICB0aGlzLnJlc3VsdFR5cGUgPSBvcHRzLnJlc3VsdFR5cGUgfHwgJ3ZhbHVlJztcbiAgdGhpcy5mbGF0dGVuID0gb3B0cy5mbGF0dGVuIHx8IGZhbHNlO1xuICB0aGlzLndyYXAgPSBoYXNPd25Qcm9wLmNhbGwob3B0cywgJ3dyYXAnKSA/IG9wdHMud3JhcCA6IHRydWU7XG4gIHRoaXMuc2FuZGJveCA9IG9wdHMuc2FuZGJveCB8fCB7fTtcbiAgdGhpcy5wcmV2ZW50RXZhbCA9IG9wdHMucHJldmVudEV2YWwgfHwgZmFsc2U7XG4gIHRoaXMucGFyZW50ID0gb3B0cy5wYXJlbnQgfHwgbnVsbDtcbiAgdGhpcy5wYXJlbnRQcm9wZXJ0eSA9IG9wdHMucGFyZW50UHJvcGVydHkgfHwgbnVsbDtcbiAgdGhpcy5jYWxsYmFjayA9IG9wdHMuY2FsbGJhY2sgfHwgY2FsbGJhY2sgfHwgbnVsbDtcblxuICB0aGlzLm90aGVyVHlwZUNhbGxiYWNrID0gb3B0cy5vdGhlclR5cGVDYWxsYmFjayB8fCBvdGhlclR5cGVDYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3Qgc3VwcGx5IGFuIG90aGVyVHlwZUNhbGxiYWNrIGNhbGxiYWNrIG9wdGlvbiAnICsgJ3dpdGggdGhlIEBvdGhlcigpIG9wZXJhdG9yLicpO1xuICB9O1xuXG4gIGlmIChvcHRzLmF1dG9zdGFydCAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgcGF0aDogb3B0T2JqID8gb3B0cy5wYXRoIDogZXhwclxuICAgIH07XG5cbiAgICBpZiAoIW9wdE9iaikge1xuICAgICAgYXJncy5qc29uID0gb2JqO1xuICAgIH0gZWxzZSBpZiAoJ2pzb24nIGluIG9wdHMpIHtcbiAgICAgIGFyZ3MuanNvbiA9IG9wdHMuanNvbjtcbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSB0aGlzLmV2YWx1YXRlKGFyZ3MpO1xuXG4gICAgaWYgKCFyZXQgfHwgdHlwZW9mIHJldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBOZXdFcnJvcihyZXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cbn0gLy8gUFVCTElDIE1FVEhPRFNcblxuXG5KU09OUGF0aC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoZXhwciwganNvbiwgY2FsbGJhY2ssIG90aGVyVHlwZUNhbGxiYWNrKSB7XG4gIGxldCBjdXJyUGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICBjdXJyUGFyZW50UHJvcGVydHkgPSB0aGlzLnBhcmVudFByb3BlcnR5O1xuICBsZXQge1xuICAgIGZsYXR0ZW4sXG4gICAgd3JhcFxuICB9ID0gdGhpcztcbiAgdGhpcy5jdXJyUmVzdWx0VHlwZSA9IHRoaXMucmVzdWx0VHlwZTtcbiAgdGhpcy5jdXJyUHJldmVudEV2YWwgPSB0aGlzLnByZXZlbnRFdmFsO1xuICB0aGlzLmN1cnJTYW5kYm94ID0gdGhpcy5zYW5kYm94O1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IHRoaXMuY2FsbGJhY2s7XG4gIHRoaXMuY3Vyck90aGVyVHlwZUNhbGxiYWNrID0gb3RoZXJUeXBlQ2FsbGJhY2sgfHwgdGhpcy5vdGhlclR5cGVDYWxsYmFjaztcbiAganNvbiA9IGpzb24gfHwgdGhpcy5qc29uO1xuICBleHByID0gZXhwciB8fCB0aGlzLnBhdGg7XG5cbiAgaWYgKGV4cHIgJiYgdHlwZW9mIGV4cHIgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGV4cHIpKSB7XG4gICAgaWYgKCFleHByLnBhdGggJiYgZXhwci5wYXRoICE9PSAnJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3Qgc3VwcGx5IGEgXCJwYXRoXCIgcHJvcGVydHkgd2hlbiBwcm92aWRpbmcgYW4gb2JqZWN0ICcgKyAnYXJndW1lbnQgdG8gSlNPTlBhdGguZXZhbHVhdGUoKS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3AuY2FsbChleHByLCAnanNvbicpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYSBcImpzb25cIiBwcm9wZXJ0eSB3aGVuIHByb3ZpZGluZyBhbiBvYmplY3QgJyArICdhcmd1bWVudCB0byBKU09OUGF0aC5ldmFsdWF0ZSgpLicpO1xuICAgIH1cblxuICAgICh7XG4gICAgICBqc29uXG4gICAgfSA9IGV4cHIpO1xuICAgIGZsYXR0ZW4gPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ2ZsYXR0ZW4nKSA/IGV4cHIuZmxhdHRlbiA6IGZsYXR0ZW47XG4gICAgdGhpcy5jdXJyUmVzdWx0VHlwZSA9IGhhc093blByb3AuY2FsbChleHByLCAncmVzdWx0VHlwZScpID8gZXhwci5yZXN1bHRUeXBlIDogdGhpcy5jdXJyUmVzdWx0VHlwZTtcbiAgICB0aGlzLmN1cnJTYW5kYm94ID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdzYW5kYm94JykgPyBleHByLnNhbmRib3ggOiB0aGlzLmN1cnJTYW5kYm94O1xuICAgIHdyYXAgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ3dyYXAnKSA/IGV4cHIud3JhcCA6IHdyYXA7XG4gICAgdGhpcy5jdXJyUHJldmVudEV2YWwgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ3ByZXZlbnRFdmFsJykgPyBleHByLnByZXZlbnRFdmFsIDogdGhpcy5jdXJyUHJldmVudEV2YWw7XG4gICAgY2FsbGJhY2sgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ2NhbGxiYWNrJykgPyBleHByLmNhbGxiYWNrIDogY2FsbGJhY2s7XG4gICAgdGhpcy5jdXJyT3RoZXJUeXBlQ2FsbGJhY2sgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ290aGVyVHlwZUNhbGxiYWNrJykgPyBleHByLm90aGVyVHlwZUNhbGxiYWNrIDogdGhpcy5jdXJyT3RoZXJUeXBlQ2FsbGJhY2s7XG4gICAgY3VyclBhcmVudCA9IGhhc093blByb3AuY2FsbChleHByLCAncGFyZW50JykgPyBleHByLnBhcmVudCA6IGN1cnJQYXJlbnQ7XG4gICAgY3VyclBhcmVudFByb3BlcnR5ID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdwYXJlbnRQcm9wZXJ0eScpID8gZXhwci5wYXJlbnRQcm9wZXJ0eSA6IGN1cnJQYXJlbnRQcm9wZXJ0eTtcbiAgICBleHByID0gZXhwci5wYXRoO1xuICB9XG5cbiAgY3VyclBhcmVudCA9IGN1cnJQYXJlbnQgfHwgbnVsbDtcbiAgY3VyclBhcmVudFByb3BlcnR5ID0gY3VyclBhcmVudFByb3BlcnR5IHx8IG51bGw7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwcikpIHtcbiAgICBleHByID0gSlNPTlBhdGgudG9QYXRoU3RyaW5nKGV4cHIpO1xuICB9XG5cbiAgaWYgKCFleHByICYmIGV4cHIgIT09ICcnIHx8ICFqc29uKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGV4cHJMaXN0ID0gSlNPTlBhdGgudG9QYXRoQXJyYXkoZXhwcik7XG5cbiAgaWYgKGV4cHJMaXN0WzBdID09PSAnJCcgJiYgZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgIGV4cHJMaXN0LnNoaWZ0KCk7XG4gIH1cblxuICB0aGlzLl9oYXNQYXJlbnRTZWxlY3RvciA9IG51bGw7XG5cbiAgY29uc3QgcmVzdWx0ID0gdGhpcy5fdHJhY2UoZXhwckxpc3QsIGpzb24sIFsnJCddLCBjdXJyUGFyZW50LCBjdXJyUGFyZW50UHJvcGVydHksIGNhbGxiYWNrKS5maWx0ZXIoZnVuY3Rpb24gKGVhKSB7XG4gICAgcmV0dXJuIGVhICYmICFlYS5pc1BhcmVudFNlbGVjdG9yO1xuICB9KTtcblxuICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gd3JhcCA/IFtdIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCF3cmFwICYmIHJlc3VsdC5sZW5ndGggPT09IDEgJiYgIXJlc3VsdFswXS5oYXNBcnJFeHByKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFByZWZlcnJlZE91dHB1dChyZXN1bHRbMF0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKHJzbHQsIGVhKSA9PiB7XG4gICAgY29uc3QgdmFsT3JQYXRoID0gdGhpcy5fZ2V0UHJlZmVycmVkT3V0cHV0KGVhKTtcblxuICAgIGlmIChmbGF0dGVuICYmIEFycmF5LmlzQXJyYXkodmFsT3JQYXRoKSkge1xuICAgICAgcnNsdCA9IHJzbHQuY29uY2F0KHZhbE9yUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzbHQucHVzaCh2YWxPclBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiByc2x0O1xuICB9LCBbXSk7XG59OyAvLyBQUklWQVRFIE1FVEhPRFNcblxuXG5KU09OUGF0aC5wcm90b3R5cGUuX2dldFByZWZlcnJlZE91dHB1dCA9IGZ1bmN0aW9uIChlYSkge1xuICBjb25zdCByZXN1bHRUeXBlID0gdGhpcy5jdXJyUmVzdWx0VHlwZTtcblxuICBzd2l0Y2ggKHJlc3VsdFR5cGUpIHtcbiAgICBjYXNlICdhbGwnOlxuICAgICAge1xuICAgICAgICBjb25zdCBwYXRoID0gQXJyYXkuaXNBcnJheShlYS5wYXRoKSA/IGVhLnBhdGggOiBKU09OUGF0aC50b1BhdGhBcnJheShlYS5wYXRoKTtcbiAgICAgICAgZWEucG9pbnRlciA9IEpTT05QYXRoLnRvUG9pbnRlcihwYXRoKTtcbiAgICAgICAgZWEucGF0aCA9IHR5cGVvZiBlYS5wYXRoID09PSAnc3RyaW5nJyA/IGVhLnBhdGggOiBKU09OUGF0aC50b1BhdGhTdHJpbmcoZWEucGF0aCk7XG4gICAgICAgIHJldHVybiBlYTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICBjYXNlICdwYXJlbnQnOlxuICAgIGNhc2UgJ3BhcmVudFByb3BlcnR5JzpcbiAgICAgIHJldHVybiBlYVtyZXN1bHRUeXBlXTtcblxuICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgcmV0dXJuIEpTT05QYXRoLnRvUGF0aFN0cmluZyhlYVtyZXN1bHRUeXBlXSk7XG5cbiAgICBjYXNlICdwb2ludGVyJzpcbiAgICAgIHJldHVybiBKU09OUGF0aC50b1BvaW50ZXIoZWEucGF0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biByZXN1bHQgdHlwZScpO1xuICB9XG59O1xuXG5KU09OUGF0aC5wcm90b3R5cGUuX2hhbmRsZUNhbGxiYWNrID0gZnVuY3Rpb24gKGZ1bGxSZXRPYmosIGNhbGxiYWNrLCB0eXBlKSB7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIGNvbnN0IHByZWZlcnJlZE91dHB1dCA9IHRoaXMuX2dldFByZWZlcnJlZE91dHB1dChmdWxsUmV0T2JqKTtcblxuICAgIGZ1bGxSZXRPYmoucGF0aCA9IHR5cGVvZiBmdWxsUmV0T2JqLnBhdGggPT09ICdzdHJpbmcnID8gZnVsbFJldE9iai5wYXRoIDogSlNPTlBhdGgudG9QYXRoU3RyaW5nKGZ1bGxSZXRPYmoucGF0aCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuXG4gICAgY2FsbGJhY2socHJlZmVycmVkT3V0cHV0LCB0eXBlLCBmdWxsUmV0T2JqKTtcbiAgfVxufTtcbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByXG4gKiBAcGFyYW0ge0pTT05PYmplY3R9IHZhbFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7UGxhaW5PYmplY3R8R2VuZXJpY0FycmF5fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRQcm9wTmFtZVxuICogQHBhcmFtIHtKU09OUGF0aENhbGxiYWNrfSBjYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFufSBoYXNBcnJFeHByXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxpdGVyYWxQcmlvcml0eVxuICogQHJldHVybnMge1JldHVybk9iamVjdHxSZXR1cm5PYmplY3RbXX1cbiAqL1xuXG5cbkpTT05QYXRoLnByb3RvdHlwZS5fdHJhY2UgPSBmdW5jdGlvbiAoZXhwciwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgaGFzQXJyRXhwciwgbGl0ZXJhbFByaW9yaXR5KSB7XG4gIC8vIE5vIGV4cHIgdG8gZm9sbG93PyByZXR1cm4gcGF0aCBhbmQgdmFsdWUgYXMgdGhlIHJlc3VsdCBvZlxuICAvLyAgdGhpcyB0cmFjZSBicmFuY2hcbiAgbGV0IHJldE9iajtcblxuICBpZiAoIWV4cHIubGVuZ3RoKSB7XG4gICAgcmV0T2JqID0ge1xuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlOiB2YWwsXG4gICAgICBwYXJlbnQsXG4gICAgICBwYXJlbnRQcm9wZXJ0eTogcGFyZW50UHJvcE5hbWUsXG4gICAgICBoYXNBcnJFeHByXG4gICAgfTtcblxuICAgIHRoaXMuX2hhbmRsZUNhbGxiYWNrKHJldE9iaiwgY2FsbGJhY2ssICd2YWx1ZScpO1xuXG4gICAgcmV0dXJuIHJldE9iajtcbiAgfVxuXG4gIGNvbnN0IGxvYyA9IGV4cHJbMF0sXG4gICAgICAgIHggPSBleHByLnNsaWNlKDEpOyAvLyBXZSBuZWVkIHRvIGdhdGhlciB0aGUgcmV0dXJuIHZhbHVlIG9mIHJlY3Vyc2l2ZSB0cmFjZSBjYWxscyBpbiBvcmRlciB0b1xuICAvLyBkbyB0aGUgcGFyZW50IHNlbCBjb21wdXRhdGlvbi5cblxuICBjb25zdCByZXQgPSBbXTtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7UmV0dXJuT2JqZWN0fFJldHVybk9iamVjdFtdfSBlbGVtc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkUmV0KGVsZW1zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbXMpKSB7XG4gICAgICAvLyBUaGlzIHdhcyBjYXVzaW5nIGV4Y2Vzc2l2ZSBzdGFjayBzaXplIGluIE5vZGUgKHdpdGggb3JcbiAgICAgIC8vICB3aXRob3V0IEJhYmVsKSBhZ2FpbnN0IG91ciBwZXJmb3JtYW5jZSB0ZXN0OlxuICAgICAgLy8gIGByZXQucHVzaCguLi5lbGVtcyk7YFxuICAgICAgZWxlbXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgcmV0LnB1c2godCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goZWxlbXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICgodHlwZW9mIGxvYyAhPT0gJ3N0cmluZycgfHwgbGl0ZXJhbFByaW9yaXR5KSAmJiB2YWwgJiYgaGFzT3duUHJvcC5jYWxsKHZhbCwgbG9jKSkge1xuICAgIC8vIHNpbXBsZSBjYXNlLS1kaXJlY3RseSBmb2xsb3cgcHJvcGVydHlcbiAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsW2xvY10sIHB1c2gocGF0aCwgbG9jKSwgdmFsLCBsb2MsIGNhbGxiYWNrLCBoYXNBcnJFeHByKSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1zd2l0Y2ggLS0gUGFydCBvZiBsYXJnZXIgYGlmYFxuICB9IGVsc2UgaWYgKGxvYyA9PT0gJyonKSB7XG4gICAgLy8gYWxsIGNoaWxkIHByb3BlcnRpZXNcbiAgICB0aGlzLl93YWxrKGxvYywgeCwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgKG0sIGwsIF94LCB2LCBwLCBwYXIsIHByLCBjYikgPT4ge1xuICAgICAgYWRkUmV0KHRoaXMuX3RyYWNlKHVuc2hpZnQobSwgX3gpLCB2LCBwLCBwYXIsIHByLCBjYiwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGxvYyA9PT0gJy4uJykge1xuICAgIC8vIGFsbCBkZXNjZW5kZW50IHBhcmVudCBwcm9wZXJ0aWVzXG4gICAgLy8gQ2hlY2sgcmVtYWluaW5nIGV4cHJlc3Npb24gd2l0aCB2YWwncyBpbW1lZGlhdGUgY2hpbGRyZW5cbiAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgaGFzQXJyRXhwcikpO1xuXG4gICAgdGhpcy5fd2Fsayhsb2MsIHgsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIChtLCBsLCBfeCwgdiwgcCwgcGFyLCBwciwgY2IpID0+IHtcbiAgICAgIC8vIFdlIGRvbid0IGpvaW4gbSBhbmQgeCBoZXJlIGJlY2F1c2Ugd2Ugb25seSB3YW50IHBhcmVudHMsXG4gICAgICAvLyAgIG5vdCBzY2FsYXIgdmFsdWVzXG4gICAgICBpZiAodHlwZW9mIHZbbV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIEtlZXAgZ29pbmcgd2l0aCByZWN1cnNpdmUgZGVzY2VudCBvbiB2YWwnc1xuICAgICAgICAvLyAgIG9iamVjdCBjaGlsZHJlblxuICAgICAgICBhZGRSZXQodGhpcy5fdHJhY2UodW5zaGlmdChsLCBfeCksIHZbbV0sIHB1c2gocCwgbSksIHYsIG0sIGNiLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfSk7IC8vIFRoZSBwYXJlbnQgc2VsIGNvbXB1dGF0aW9uIGlzIGhhbmRsZWQgaW4gdGhlIGZyYW1lIGFib3ZlIHVzaW5nIHRoZVxuICAgIC8vIGFuY2VzdG9yIG9iamVjdCBvZiB2YWxcblxuICB9IGVsc2UgaWYgKGxvYyA9PT0gJ14nKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYSBmaW5hbCBlbmRwb2ludCwgc28gd2UgZG8gbm90IGludm9rZSB0aGUgY2FsbGJhY2sgaGVyZVxuICAgIHRoaXMuX2hhc1BhcmVudFNlbGVjdG9yID0gdHJ1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aC5zbGljZSgwLCAtMSksXG4gICAgICBleHByOiB4LFxuICAgICAgaXNQYXJlbnRTZWxlY3RvcjogdHJ1ZVxuICAgIH07XG4gIH0gZWxzZSBpZiAobG9jID09PSAnficpIHtcbiAgICAvLyBwcm9wZXJ0eSBuYW1lXG4gICAgcmV0T2JqID0ge1xuICAgICAgcGF0aDogcHVzaChwYXRoLCBsb2MpLFxuICAgICAgdmFsdWU6IHBhcmVudFByb3BOYW1lLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50UHJvcGVydHk6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5faGFuZGxlQ2FsbGJhY2socmV0T2JqLCBjYWxsYmFjaywgJ3Byb3BlcnR5Jyk7XG5cbiAgICByZXR1cm4gcmV0T2JqO1xuICB9IGVsc2UgaWYgKGxvYyA9PT0gJyQnKSB7XG4gICAgLy8gcm9vdCBvbmx5XG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHgsIHZhbCwgcGF0aCwgbnVsbCwgbnVsbCwgY2FsbGJhY2ssIGhhc0FyckV4cHIpKTtcbiAgfSBlbHNlIGlmICgvXigtP1xcZCopOigtP1xcZCopOj8oXFxkKikkL3UudGVzdChsb2MpKSB7XG4gICAgLy8gW3N0YXJ0OmVuZDpzdGVwXSAgUHl0aG9uIHNsaWNlIHN5bnRheFxuICAgIGFkZFJldCh0aGlzLl9zbGljZShsb2MsIHgsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2spKTtcbiAgfSBlbHNlIGlmIChsb2MuaW5kZXhPZignPygnKSA9PT0gMCkge1xuICAgIC8vIFs/KGV4cHIpXSAoZmlsdGVyaW5nKVxuICAgIGlmICh0aGlzLmN1cnJQcmV2ZW50RXZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmFsIFs/KGV4cHIpXSBwcmV2ZW50ZWQgaW4gSlNPTlBhdGggZXhwcmVzc2lvbi4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl93YWxrKGxvYywgeCwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgKG0sIGwsIF94LCB2LCBwLCBwYXIsIHByLCBjYikgPT4ge1xuICAgICAgaWYgKHRoaXMuX2V2YWwobC5yZXBsYWNlKC9eXFw/XFwoKC4qPylcXCkkL3UsICckMScpLCB2W21dLCBtLCBwLCBwYXIsIHByKSkge1xuICAgICAgICBhZGRSZXQodGhpcy5fdHJhY2UodW5zaGlmdChtLCBfeCksIHYsIHAsIHBhciwgcHIsIGNiLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobG9jWzBdID09PSAnKCcpIHtcbiAgICAvLyBbKGV4cHIpXSAoZHluYW1pYyBwcm9wZXJ0eS9pbmRleClcbiAgICBpZiAodGhpcy5jdXJyUHJldmVudEV2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXZhbCBbKGV4cHIpXSBwcmV2ZW50ZWQgaW4gSlNPTlBhdGggZXhwcmVzc2lvbi4nKTtcbiAgICB9IC8vIEFzIHRoaXMgd2lsbCByZXNvbHZlIHRvIGEgcHJvcGVydHkgbmFtZSAoYnV0IHdlIGRvbid0IGtub3cgaXRcbiAgICAvLyAgeWV0KSwgcHJvcGVydHkgYW5kIHBhcmVudCBpbmZvcm1hdGlvbiBpcyByZWxhdGl2ZSB0byB0aGVcbiAgICAvLyAgcGFyZW50IG9mIHRoZSBwcm9wZXJ0eSB0byB3aGljaCB0aGlzIGV4cHJlc3Npb24gd2lsbCByZXNvbHZlXG5cblxuICAgIGFkZFJldCh0aGlzLl90cmFjZSh1bnNoaWZ0KHRoaXMuX2V2YWwobG9jLCB2YWwsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aC5zbGljZSgwLCAtMSksIHBhcmVudCwgcGFyZW50UHJvcE5hbWUpLCB4KSwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgaGFzQXJyRXhwcikpO1xuICB9IGVsc2UgaWYgKGxvY1swXSA9PT0gJ0AnKSB7XG4gICAgLy8gdmFsdWUgdHlwZTogQGJvb2xlYW4oKSwgZXRjLlxuICAgIGxldCBhZGRUeXBlID0gZmFsc2U7XG4gICAgY29uc3QgdmFsdWVUeXBlID0gbG9jLnNsaWNlKDEsIC0yKTtcblxuICAgIHN3aXRjaCAodmFsdWVUeXBlKSB7XG4gICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBpZiAoIXZhbCB8fCAhWydvYmplY3QnLCAnZnVuY3Rpb24nXS5pbmNsdWRlcyh0eXBlb2YgdmFsKSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IHZhbHVlVHlwZSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbCkgJiYgISh2YWwgJSAxKSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsKSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ25vbkZpbml0ZSc6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gdmFsdWVUeXBlKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb3RoZXInOlxuICAgICAgICBhZGRUeXBlID0gdGhpcy5jdXJyT3RoZXJUeXBlQ2FsbGJhY2sodmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biB2YWx1ZSB0eXBlICcgKyB2YWx1ZVR5cGUpO1xuICAgIH1cblxuICAgIGlmIChhZGRUeXBlKSB7XG4gICAgICByZXRPYmogPSB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50UHJvcGVydHk6IHBhcmVudFByb3BOYW1lXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9oYW5kbGVDYWxsYmFjayhyZXRPYmosIGNhbGxiYWNrLCAndmFsdWUnKTtcblxuICAgICAgcmV0dXJuIHJldE9iajtcbiAgICB9IC8vIGAtZXNjYXBlZCBwcm9wZXJ0eVxuXG4gIH0gZWxzZSBpZiAobG9jWzBdID09PSAnYCcgJiYgdmFsICYmIGhhc093blByb3AuY2FsbCh2YWwsIGxvYy5zbGljZSgxKSkpIHtcbiAgICBjb25zdCBsb2NQcm9wID0gbG9jLnNsaWNlKDEpO1xuICAgIGFkZFJldCh0aGlzLl90cmFjZSh4LCB2YWxbbG9jUHJvcF0sIHB1c2gocGF0aCwgbG9jUHJvcCksIHZhbCwgbG9jUHJvcCwgY2FsbGJhY2ssIGhhc0FyckV4cHIsIHRydWUpKTtcbiAgfSBlbHNlIGlmIChsb2MuaW5jbHVkZXMoJywnKSkge1xuICAgIC8vIFtuYW1lMSxuYW1lMiwuLi5dXG4gICAgY29uc3QgcGFydHMgPSBsb2Muc3BsaXQoJywnKTtcblxuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgYWRkUmV0KHRoaXMuX3RyYWNlKHVuc2hpZnQocGFydCwgeCksIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIHRydWUpKTtcbiAgICB9IC8vIHNpbXBsZSBjYXNlLS1kaXJlY3RseSBmb2xsb3cgcHJvcGVydHlcblxuICB9IGVsc2UgaWYgKCFsaXRlcmFsUHJpb3JpdHkgJiYgdmFsICYmIGhhc093blByb3AuY2FsbCh2YWwsIGxvYykpIHtcbiAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsW2xvY10sIHB1c2gocGF0aCwgbG9jKSwgdmFsLCBsb2MsIGNhbGxiYWNrLCBoYXNBcnJFeHByLCB0cnVlKSk7XG4gIH0gLy8gV2UgY2hlY2sgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZm9yIHBhcmVudCBzZWxlY3Rpb25zLiBGb3IgcGFyZW50XG4gIC8vIHNlbGVjdGlvbnMgd2UgZGlzY2FyZCB0aGUgdmFsdWUgb2JqZWN0IGFuZCBjb250aW51ZSB0aGUgdHJhY2Ugd2l0aCB0aGVcbiAgLy8gY3VycmVudCB2YWwgb2JqZWN0XG5cblxuICBpZiAodGhpcy5faGFzUGFyZW50U2VsZWN0b3IpIHtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHJldC5sZW5ndGg7IHQrKykge1xuICAgICAgY29uc3QgcmV0dCA9IHJldFt0XTtcblxuICAgICAgaWYgKHJldHQgJiYgcmV0dC5pc1BhcmVudFNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHRoaXMuX3RyYWNlKHJldHQuZXhwciwgdmFsLCByZXR0LnBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCBoYXNBcnJFeHByKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0bXApKSB7XG4gICAgICAgICAgcmV0W3RdID0gdG1wWzBdO1xuICAgICAgICAgIGNvbnN0IHRsID0gdG1wLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAobGV0IHR0ID0gMTsgdHQgPCB0bDsgdHQrKykge1xuICAgICAgICAgICAgdCsrO1xuICAgICAgICAgICAgcmV0LnNwbGljZSh0LCAwLCB0bXBbdHRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0W3RdID0gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbkpTT05QYXRoLnByb3RvdHlwZS5fd2FsayA9IGZ1bmN0aW9uIChsb2MsIGV4cHIsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIGYpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNvbnN0IG4gPSB2YWwubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGYoaSwgbG9jLCBleHByLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgT2JqZWN0LmtleXModmFsKS5mb3JFYWNoKG0gPT4ge1xuICAgICAgZihtLCBsb2MsIGV4cHIsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG59O1xuXG5KU09OUGF0aC5wcm90b3R5cGUuX3NsaWNlID0gZnVuY3Rpb24gKGxvYywgZXhwciwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBsZW4gPSB2YWwubGVuZ3RoLFxuICAgICAgICBwYXJ0cyA9IGxvYy5zcGxpdCgnOicpLFxuICAgICAgICBzdGVwID0gcGFydHNbMl0gJiYgTnVtYmVyLnBhcnNlSW50KHBhcnRzWzJdKSB8fCAxO1xuICBsZXQgc3RhcnQgPSBwYXJ0c1swXSAmJiBOdW1iZXIucGFyc2VJbnQocGFydHNbMF0pIHx8IDAsXG4gICAgICBlbmQgPSBwYXJ0c1sxXSAmJiBOdW1iZXIucGFyc2VJbnQocGFydHNbMV0pIHx8IGxlbjtcbiAgc3RhcnQgPSBzdGFydCA8IDAgPyBNYXRoLm1heCgwLCBzdGFydCArIGxlbikgOiBNYXRoLm1pbihsZW4sIHN0YXJ0KTtcbiAgZW5kID0gZW5kIDwgMCA/IE1hdGgubWF4KDAsIGVuZCArIGxlbikgOiBNYXRoLm1pbihsZW4sIGVuZCk7XG4gIGNvbnN0IHJldCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBzdGVwKSB7XG4gICAgY29uc3QgdG1wID0gdGhpcy5fdHJhY2UodW5zaGlmdChpLCBleHByKSwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgdHJ1ZSk7IC8vIFNob3VsZCBvbmx5IGJlIHBvc3NpYmxlIHRvIGJlIGFuIGFycmF5IGhlcmUgc2luY2UgZmlyc3QgcGFydCBvZlxuICAgIC8vICAgYGB1bnNoaWZ0KGksIGV4cHIpYCBwYXNzZWQgaW4gYWJvdmUgd291bGQgbm90IGJlIGVtcHR5LCBub3IgYH5gLFxuICAgIC8vICAgICBub3IgYmVnaW4gd2l0aCBgQGAgKGFzIGNvdWxkIHJldHVybiBvYmplY3RzKVxuICAgIC8vIFRoaXMgd2FzIGNhdXNpbmcgZXhjZXNzaXZlIHN0YWNrIHNpemUgaW4gTm9kZSAod2l0aCBvclxuICAgIC8vICB3aXRob3V0IEJhYmVsKSBhZ2FpbnN0IG91ciBwZXJmb3JtYW5jZSB0ZXN0OiBgcmV0LnB1c2goLi4udG1wKTtgXG5cblxuICAgIHRtcC5mb3JFYWNoKHQgPT4ge1xuICAgICAgcmV0LnB1c2godCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuSlNPTlBhdGgucHJvdG90eXBlLl9ldmFsID0gZnVuY3Rpb24gKGNvZGUsIF92LCBfdm5hbWUsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUpIHtcbiAgaWYgKGNvZGUuaW5jbHVkZXMoJ0BwYXJlbnRQcm9wZXJ0eScpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9wYXJlbnRQcm9wZXJ0eSA9IHBhcmVudFByb3BOYW1lO1xuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL0BwYXJlbnRQcm9wZXJ0eS9ndSwgJ18kX3BhcmVudFByb3BlcnR5Jyk7XG4gIH1cblxuICBpZiAoY29kZS5pbmNsdWRlcygnQHBhcmVudCcpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgY29kZSA9IGNvZGUucmVwbGFjZSgvQHBhcmVudC9ndSwgJ18kX3BhcmVudCcpO1xuICB9XG5cbiAgaWYgKGNvZGUuaW5jbHVkZXMoJ0Bwcm9wZXJ0eScpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9wcm9wZXJ0eSA9IF92bmFtZTtcbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9AcHJvcGVydHkvZ3UsICdfJF9wcm9wZXJ0eScpO1xuICB9XG5cbiAgaWYgKGNvZGUuaW5jbHVkZXMoJ0BwYXRoJykpIHtcbiAgICB0aGlzLmN1cnJTYW5kYm94Ll8kX3BhdGggPSBKU09OUGF0aC50b1BhdGhTdHJpbmcocGF0aC5jb25jYXQoW192bmFtZV0pKTtcbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9AcGF0aC9ndSwgJ18kX3BhdGgnKTtcbiAgfVxuXG4gIGlmIChjb2RlLmluY2x1ZGVzKCdAcm9vdCcpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9yb290ID0gdGhpcy5qc29uO1xuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL0Byb290L2d1LCAnXyRfcm9vdCcpO1xuICB9XG5cbiAgaWYgKC9AKFsuXFxzKVtdKS91LnRlc3QoY29kZSkpIHtcbiAgICB0aGlzLmN1cnJTYW5kYm94Ll8kX3YgPSBfdjtcbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9AKFsuXFxzKVtdKS9ndSwgJ18kX3YkMScpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy52bS5ydW5Jbk5ld0NvbnRleHQoY29kZSwgdGhpcy5jdXJyU2FuZGJveCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIHRocm93IG5ldyBFcnJvcignanNvblBhdGg6ICcgKyBlLm1lc3NhZ2UgKyAnOiAnICsgY29kZSk7XG4gIH1cbn07IC8vIFBVQkxJQyBDTEFTUyBQUk9QRVJUSUVTIEFORCBNRVRIT0RTXG4vLyBDb3VsZCBzdG9yZSB0aGUgY2FjaGUgb2JqZWN0IGl0c2VsZlxuXG5cbkpTT05QYXRoLmNhY2hlID0ge307XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhBcnIgQXJyYXkgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggc3RyaW5nXG4gKi9cblxuSlNPTlBhdGgudG9QYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhBcnIpIHtcbiAgY29uc3QgeCA9IHBhdGhBcnIsXG4gICAgICAgIG4gPSB4Lmxlbmd0aDtcbiAgbGV0IHAgPSAnJCc7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoIS9eKH58XFxefEAuKj9cXChcXCkpJC91LnRlc3QoeFtpXSkpIHtcbiAgICAgIHAgKz0gL15bMC05Kl0rJC91LnRlc3QoeFtpXSkgPyAnWycgKyB4W2ldICsgJ10nIDogXCJbJ1wiICsgeFtpXSArIFwiJ11cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcDtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2ludGVyIEpTT04gUGF0aFxuICogQHJldHVybnMge3N0cmluZ30gSlNPTiBQb2ludGVyXG4gKi9cblxuXG5KU09OUGF0aC50b1BvaW50ZXIgPSBmdW5jdGlvbiAocG9pbnRlcikge1xuICBjb25zdCB4ID0gcG9pbnRlcixcbiAgICAgICAgbiA9IHgubGVuZ3RoO1xuICBsZXQgcCA9ICcnO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKCEvXih+fFxcXnxALio/XFwoXFwpKSQvdS50ZXN0KHhbaV0pKSB7XG4gICAgICBwICs9ICcvJyArIHhbaV0udG9TdHJpbmcoKS5yZXBsYWNlKC9+L2d1LCAnfjAnKS5yZXBsYWNlKC9cXC8vZ3UsICd+MScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHIgRXhwcmVzc2lvbiB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cblxuXG5KU09OUGF0aC50b1BhdGhBcnJheSA9IGZ1bmN0aW9uIChleHByKSB7XG4gIGNvbnN0IHtcbiAgICBjYWNoZVxuICB9ID0gSlNPTlBhdGg7XG5cbiAgaWYgKGNhY2hlW2V4cHJdKSB7XG4gICAgcmV0dXJuIGNhY2hlW2V4cHJdLmNvbmNhdCgpO1xuICB9XG5cbiAgY29uc3Qgc3VieCA9IFtdO1xuICBjb25zdCBub3JtYWxpemVkID0gZXhwciAvLyBQcm9wZXJ0aWVzXG4gIC5yZXBsYWNlKC9AKD86bnVsbHxib29sZWFufG51bWJlcnxzdHJpbmd8aW50ZWdlcnx1bmRlZmluZWR8bm9uRmluaXRlfHNjYWxhcnxhcnJheXxvYmplY3R8ZnVuY3Rpb258b3RoZXIpXFwoXFwpL2d1LCAnOyQmOycpIC8vIFBhcmVudGhldGljYWwgZXZhbHVhdGlvbnMgKGZpbHRlcmluZyBhbmQgb3RoZXJ3aXNlKSwgZGlyZWN0bHlcbiAgLy8gICB3aXRoaW4gYnJhY2tldHMgb3Igc2luZ2xlIHF1b3Rlc1xuICAucmVwbGFjZSgvW1snXShcXD8/XFwoLio/XFwpKVtcXF0nXS9ndSwgZnVuY3Rpb24gKCQwLCAkMSkge1xuICAgIHJldHVybiAnWyMnICsgKHN1YngucHVzaCgkMSkgLSAxKSArICddJztcbiAgfSkgLy8gRXNjYXBlIHBlcmlvZHMgYW5kIHRpbGRlcyB3aXRoaW4gcHJvcGVydGllc1xuICAucmVwbGFjZSgvXFxbWydcIl0oW14nXFxdXSopWydcIl1cXF0vZ3UsIGZ1bmN0aW9uICgkMCwgcHJvcCkge1xuICAgIHJldHVybiBcIlsnXCIgKyBwcm9wLnJlcGxhY2UoL1xcLi9ndSwgJyVAJScpLnJlcGxhY2UoL34vZ3UsICclJUBAJSUnKSArIFwiJ11cIjtcbiAgfSkgLy8gUHJvcGVydGllcyBvcGVyYXRvclxuICAucmVwbGFjZSgvfi9ndSwgJzt+OycpIC8vIFNwbGl0IGJ5IHByb3BlcnR5IGJvdW5kYXJpZXNcbiAgLnJlcGxhY2UoL1snXCJdP1xcLlsnXCJdPyg/IVteW10qXFxdKXxcXFtbJ1wiXT8vZ3UsICc7JykgLy8gUmVpbnNlcnQgcGVyaW9kcyB3aXRoaW4gcHJvcGVydGllc1xuICAucmVwbGFjZSgvJUAlL2d1LCAnLicpIC8vIFJlaW5zZXJ0IHRpbGRlcyB3aXRoaW4gcHJvcGVydGllc1xuICAucmVwbGFjZSgvJSVAQCUlL2d1LCAnficpIC8vIFBhcmVudFxuICAucmVwbGFjZSgvKD86Oyk/KFxcXispKD86Oyk/L2d1LCBmdW5jdGlvbiAoJDAsIHVwcykge1xuICAgIHJldHVybiAnOycgKyB1cHMuc3BsaXQoJycpLmpvaW4oJzsnKSArICc7JztcbiAgfSkgLy8gRGVzY2VuZGVudHNcbiAgLnJlcGxhY2UoLzs7O3w7Oy9ndSwgJzsuLjsnKSAvLyBSZW1vdmUgdHJhaWxpbmdcbiAgLnJlcGxhY2UoLzskfCc/XFxdfCckL2d1LCAnJyk7XG4gIGNvbnN0IGV4cHJMaXN0ID0gbm9ybWFsaXplZC5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoZXhwKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleHAubWF0Y2goLyMoXFxkKykvdSk7XG4gICAgcmV0dXJuICFtYXRjaCB8fCAhbWF0Y2hbMV0gPyBleHAgOiBzdWJ4W21hdGNoWzFdXTtcbiAgfSk7XG4gIGNhY2hlW2V4cHJdID0gZXhwckxpc3Q7XG4gIHJldHVybiBjYWNoZVtleHByXS5jb25jYXQoKTtcbn07XG5cbkpTT05QYXRoLnByb3RvdHlwZS52bSA9IHZtO1xuXG5leHBvcnQgeyBKU09OUGF0aCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonpath-plus/dist/index-node-esm.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/jsonpath-plus/dist/index-node-esm.mjs":
/*!************************************************************!*\
  !*** ./node_modules/jsonpath-plus/dist/index-node-esm.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONPath: () => (/* binding */ JSONPath)\n/* harmony export */ });\n/* harmony import */ var vm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vm */ \"vm\");\n\n\nconst {\n  hasOwnProperty: hasOwnProp\n} = Object.prototype;\n/**\n* @typedef {null|boolean|number|string|PlainObject|GenericArray} JSONObject\n*/\n\n/**\n * Copies array and then pushes item into it.\n * @param {GenericArray} arr Array to copy and into which to push\n * @param {any} item Array item to add (to end)\n * @returns {GenericArray} Copy of the original array\n */\n\nfunction push(arr, item) {\n  arr = arr.slice();\n  arr.push(item);\n  return arr;\n}\n/**\n * Copies array and then unshifts item into it.\n * @param {any} item Array item to add (to beginning)\n * @param {GenericArray} arr Array to copy and into which to unshift\n * @returns {GenericArray} Copy of the original array\n */\n\n\nfunction unshift(item, arr) {\n  arr = arr.slice();\n  arr.unshift(item);\n  return arr;\n}\n/**\n * Caught when JSONPath is used without `new` but rethrown if with `new`\n * @extends Error\n */\n\n\nclass NewError extends Error {\n  /**\n   * @param {any} value The evaluated scalar value\n   */\n  constructor(value) {\n    super('JSONPath should not be called with \"new\" (it prevents return ' + 'of (unwrapped) scalar values)');\n    this.avoidNew = true;\n    this.value = value;\n    this.name = 'NewError';\n  }\n\n}\n/**\n* @typedef {PlainObject} ReturnObject\n* @property {string} path\n* @property {JSONObject} value\n* @property {PlainObject|GenericArray} parent\n* @property {string} parentProperty\n*/\n\n/**\n* @callback JSONPathCallback\n* @param {string|PlainObject} preferredOutput\n* @param {\"value\"|\"property\"} type\n* @param {ReturnObject} fullRetObj\n* @returns {void}\n*/\n\n/**\n* @callback OtherTypeCallback\n* @param {JSONObject} val\n* @param {string} path\n* @param {PlainObject|GenericArray} parent\n* @param {string} parentPropName\n* @returns {boolean}\n*/\n\n/* eslint-disable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */\n\n/**\n * @typedef {PlainObject} JSONPathOptions\n * @property {JSON} json\n * @property {string|string[]} path\n * @property {\"value\"|\"path\"|\"pointer\"|\"parent\"|\"parentProperty\"|\"all\"} [resultType=\"value\"]\n * @property {boolean} [flatten=false]\n * @property {boolean} [wrap=true]\n * @property {PlainObject} [sandbox={}]\n * @property {boolean} [preventEval=false]\n * @property {PlainObject|GenericArray|null} [parent=null]\n * @property {string|null} [parentProperty=null]\n * @property {JSONPathCallback} [callback]\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\n *   function which throws on encountering `@other`\n * @property {boolean} [autostart=true]\n */\n\n/* eslint-enable max-len -- Can make multiline type after https://github.com/syavorsky/comment-parser/issues/109 */\n\n/**\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\n * @param {string} [expr] JSON path to evaluate\n * @param {JSON} [obj] JSON object to evaluate against\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\n *     per `resultType`, 2) `\"value\"|\"property\"`, 3) Full returned object with\n *     all payloads\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\n *   of one's query, this will be invoked with the value of the item, its\n *   path, its parent, and its parent's property name, and it should return\n *   a boolean indicating whether the supplied value belongs to the \"other\"\n *   type or not (or it may handle transformations and return `false`).\n * @returns {JSONPath}\n * @class\n */\n\n\nfunction JSONPath(opts, expr, obj, callback, otherTypeCallback) {\n  // eslint-disable-next-line no-restricted-syntax\n  if (!(this instanceof JSONPath)) {\n    try {\n      return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\n    } catch (e) {\n      if (!e.avoidNew) {\n        throw e;\n      }\n\n      return e.value;\n    }\n  }\n\n  if (typeof opts === 'string') {\n    otherTypeCallback = callback;\n    callback = obj;\n    obj = expr;\n    expr = opts;\n    opts = null;\n  }\n\n  const optObj = opts && typeof opts === 'object';\n  opts = opts || {};\n  this.json = opts.json || obj;\n  this.path = opts.path || expr;\n  this.resultType = opts.resultType || 'value';\n  this.flatten = opts.flatten || false;\n  this.wrap = hasOwnProp.call(opts, 'wrap') ? opts.wrap : true;\n  this.sandbox = opts.sandbox || {};\n  this.preventEval = opts.preventEval || false;\n  this.parent = opts.parent || null;\n  this.parentProperty = opts.parentProperty || null;\n  this.callback = opts.callback || callback || null;\n\n  this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {\n    throw new TypeError('You must supply an otherTypeCallback callback option ' + 'with the @other() operator.');\n  };\n\n  if (opts.autostart !== false) {\n    const args = {\n      path: optObj ? opts.path : expr\n    };\n\n    if (!optObj) {\n      args.json = obj;\n    } else if ('json' in opts) {\n      args.json = opts.json;\n    }\n\n    const ret = this.evaluate(args);\n\n    if (!ret || typeof ret !== 'object') {\n      throw new NewError(ret);\n    }\n\n    return ret;\n  }\n} // PUBLIC METHODS\n\n\nJSONPath.prototype.evaluate = function (expr, json, callback, otherTypeCallback) {\n  let currParent = this.parent,\n      currParentProperty = this.parentProperty;\n  let {\n    flatten,\n    wrap\n  } = this;\n  this.currResultType = this.resultType;\n  this.currPreventEval = this.preventEval;\n  this.currSandbox = this.sandbox;\n  callback = callback || this.callback;\n  this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\n  json = json || this.json;\n  expr = expr || this.path;\n\n  if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\n    if (!expr.path && expr.path !== '') {\n      throw new TypeError('You must supply a \"path\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n\n    if (!hasOwnProp.call(expr, 'json')) {\n      throw new TypeError('You must supply a \"json\" property when providing an object ' + 'argument to JSONPath.evaluate().');\n    }\n\n    ({\n      json\n    } = expr);\n    flatten = hasOwnProp.call(expr, 'flatten') ? expr.flatten : flatten;\n    this.currResultType = hasOwnProp.call(expr, 'resultType') ? expr.resultType : this.currResultType;\n    this.currSandbox = hasOwnProp.call(expr, 'sandbox') ? expr.sandbox : this.currSandbox;\n    wrap = hasOwnProp.call(expr, 'wrap') ? expr.wrap : wrap;\n    this.currPreventEval = hasOwnProp.call(expr, 'preventEval') ? expr.preventEval : this.currPreventEval;\n    callback = hasOwnProp.call(expr, 'callback') ? expr.callback : callback;\n    this.currOtherTypeCallback = hasOwnProp.call(expr, 'otherTypeCallback') ? expr.otherTypeCallback : this.currOtherTypeCallback;\n    currParent = hasOwnProp.call(expr, 'parent') ? expr.parent : currParent;\n    currParentProperty = hasOwnProp.call(expr, 'parentProperty') ? expr.parentProperty : currParentProperty;\n    expr = expr.path;\n  }\n\n  currParent = currParent || null;\n  currParentProperty = currParentProperty || null;\n\n  if (Array.isArray(expr)) {\n    expr = JSONPath.toPathString(expr);\n  }\n\n  if (!expr && expr !== '' || !json) {\n    return undefined;\n  }\n\n  const exprList = JSONPath.toPathArray(expr);\n\n  if (exprList[0] === '$' && exprList.length > 1) {\n    exprList.shift();\n  }\n\n  this._hasParentSelector = null;\n\n  const result = this._trace(exprList, json, ['$'], currParent, currParentProperty, callback).filter(function (ea) {\n    return ea && !ea.isParentSelector;\n  });\n\n  if (!result.length) {\n    return wrap ? [] : undefined;\n  }\n\n  if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\n    return this._getPreferredOutput(result[0]);\n  }\n\n  return result.reduce((rslt, ea) => {\n    const valOrPath = this._getPreferredOutput(ea);\n\n    if (flatten && Array.isArray(valOrPath)) {\n      rslt = rslt.concat(valOrPath);\n    } else {\n      rslt.push(valOrPath);\n    }\n\n    return rslt;\n  }, []);\n}; // PRIVATE METHODS\n\n\nJSONPath.prototype._getPreferredOutput = function (ea) {\n  const resultType = this.currResultType;\n\n  switch (resultType) {\n    case 'all':\n      {\n        const path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);\n        ea.pointer = JSONPath.toPointer(path);\n        ea.path = typeof ea.path === 'string' ? ea.path : JSONPath.toPathString(ea.path);\n        return ea;\n      }\n\n    case 'value':\n    case 'parent':\n    case 'parentProperty':\n      return ea[resultType];\n\n    case 'path':\n      return JSONPath.toPathString(ea[resultType]);\n\n    case 'pointer':\n      return JSONPath.toPointer(ea.path);\n\n    default:\n      throw new TypeError('Unknown result type');\n  }\n};\n\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\n  if (callback) {\n    const preferredOutput = this._getPreferredOutput(fullRetObj);\n\n    fullRetObj.path = typeof fullRetObj.path === 'string' ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path); // eslint-disable-next-line node/callback-return\n\n    callback(preferredOutput, type, fullRetObj);\n  }\n};\n/**\n *\n * @param {string} expr\n * @param {JSONObject} val\n * @param {string} path\n * @param {PlainObject|GenericArray} parent\n * @param {string} parentPropName\n * @param {JSONPathCallback} callback\n * @param {boolean} hasArrExpr\n * @param {boolean} literalPriority\n * @returns {ReturnObject|ReturnObject[]}\n */\n\n\nJSONPath.prototype._trace = function (expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {\n  // No expr to follow? return path and value as the result of\n  //  this trace branch\n  let retObj;\n\n  if (!expr.length) {\n    retObj = {\n      path,\n      value: val,\n      parent,\n      parentProperty: parentPropName,\n      hasArrExpr\n    };\n\n    this._handleCallback(retObj, callback, 'value');\n\n    return retObj;\n  }\n\n  const loc = expr[0],\n        x = expr.slice(1); // We need to gather the return value of recursive trace calls in order to\n  // do the parent sel computation.\n\n  const ret = [];\n  /**\n   *\n   * @param {ReturnObject|ReturnObject[]} elems\n   * @returns {void}\n   */\n\n  function addRet(elems) {\n    if (Array.isArray(elems)) {\n      // This was causing excessive stack size in Node (with or\n      //  without Babel) against our performance test:\n      //  `ret.push(...elems);`\n      elems.forEach(t => {\n        ret.push(t);\n      });\n    } else {\n      ret.push(elems);\n    }\n  }\n\n  if ((typeof loc !== 'string' || literalPriority) && val && hasOwnProp.call(val, loc)) {\n    // simple case--directly follow property\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr)); // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\n  } else if (loc === '*') {\n    // all child properties\n    this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb) => {\n      addRet(this._trace(unshift(m, _x), v, p, par, pr, cb, true, true));\n    });\n  } else if (loc === '..') {\n    // all descendent parent properties\n    // Check remaining expression with val's immediate children\n    addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));\n\n    this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb) => {\n      // We don't join m and x here because we only want parents,\n      //   not scalar values\n      if (typeof v[m] === 'object') {\n        // Keep going with recursive descent on val's\n        //   object children\n        addRet(this._trace(unshift(l, _x), v[m], push(p, m), v, m, cb, true));\n      }\n    }); // The parent sel computation is handled in the frame above using the\n    // ancestor object of val\n\n  } else if (loc === '^') {\n    // This is not a final endpoint, so we do not invoke the callback here\n    this._hasParentSelector = true;\n    return {\n      path: path.slice(0, -1),\n      expr: x,\n      isParentSelector: true\n    };\n  } else if (loc === '~') {\n    // property name\n    retObj = {\n      path: push(path, loc),\n      value: parentPropName,\n      parent,\n      parentProperty: null\n    };\n\n    this._handleCallback(retObj, callback, 'property');\n\n    return retObj;\n  } else if (loc === '$') {\n    // root only\n    addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\n  } else if (/^(-?\\d*):(-?\\d*):?(\\d*)$/u.test(loc)) {\n    // [start:end:step]  Python slice syntax\n    addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));\n  } else if (loc.indexOf('?(') === 0) {\n    // [?(expr)] (filtering)\n    if (this.currPreventEval) {\n      throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\n    }\n\n    this._walk(loc, x, val, path, parent, parentPropName, callback, (m, l, _x, v, p, par, pr, cb) => {\n      if (this._eval(l.replace(/^\\?\\((.*?)\\)$/u, '$1'), v[m], m, p, par, pr)) {\n        addRet(this._trace(unshift(m, _x), v, p, par, pr, cb, true));\n      }\n    });\n  } else if (loc[0] === '(') {\n    // [(expr)] (dynamic property/index)\n    if (this.currPreventEval) {\n      throw new Error('Eval [(expr)] prevented in JSONPath expression.');\n    } // As this will resolve to a property name (but we don't know it\n    //  yet), property and parent information is relative to the\n    //  parent of the property to which this expression will resolve\n\n\n    addRet(this._trace(unshift(this._eval(loc, val, path[path.length - 1], path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));\n  } else if (loc[0] === '@') {\n    // value type: @boolean(), etc.\n    let addType = false;\n    const valueType = loc.slice(1, -2);\n\n    switch (valueType) {\n      case 'scalar':\n        if (!val || !['object', 'function'].includes(typeof val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'boolean':\n      case 'string':\n      case 'undefined':\n      case 'function':\n        // eslint-disable-next-line valid-typeof\n        if (typeof val === valueType) {\n          addType = true;\n        }\n\n        break;\n\n      case 'integer':\n        if (Number.isFinite(val) && !(val % 1)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'number':\n        if (Number.isFinite(val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'nonFinite':\n        if (typeof val === 'number' && !Number.isFinite(val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'object':\n        // eslint-disable-next-line valid-typeof\n        if (val && typeof val === valueType) {\n          addType = true;\n        }\n\n        break;\n\n      case 'array':\n        if (Array.isArray(val)) {\n          addType = true;\n        }\n\n        break;\n\n      case 'other':\n        addType = this.currOtherTypeCallback(val, path, parent, parentPropName);\n        break;\n\n      case 'null':\n        if (val === null) {\n          addType = true;\n        }\n\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new TypeError('Unknown value type ' + valueType);\n    }\n\n    if (addType) {\n      retObj = {\n        path,\n        value: val,\n        parent,\n        parentProperty: parentPropName\n      };\n\n      this._handleCallback(retObj, callback, 'value');\n\n      return retObj;\n    } // `-escaped property\n\n  } else if (loc[0] === '`' && val && hasOwnProp.call(val, loc.slice(1))) {\n    const locProp = loc.slice(1);\n    addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));\n  } else if (loc.includes(',')) {\n    // [name1,name2,...]\n    const parts = loc.split(',');\n\n    for (const part of parts) {\n      addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));\n    } // simple case--directly follow property\n\n  } else if (!literalPriority && val && hasOwnProp.call(val, loc)) {\n    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));\n  } // We check the resulting values for parent selections. For parent\n  // selections we discard the value object and continue the trace with the\n  // current val object\n\n\n  if (this._hasParentSelector) {\n    for (let t = 0; t < ret.length; t++) {\n      const rett = ret[t];\n\n      if (rett && rett.isParentSelector) {\n        const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);\n\n        if (Array.isArray(tmp)) {\n          ret[t] = tmp[0];\n          const tl = tmp.length;\n\n          for (let tt = 1; tt < tl; tt++) {\n            t++;\n            ret.splice(t, 0, tmp[tt]);\n          }\n        } else {\n          ret[t] = tmp;\n        }\n      }\n    }\n  }\n\n  return ret;\n};\n\nJSONPath.prototype._walk = function (loc, expr, val, path, parent, parentPropName, callback, f) {\n  if (Array.isArray(val)) {\n    const n = val.length;\n\n    for (let i = 0; i < n; i++) {\n      f(i, loc, expr, val, path, parent, parentPropName, callback);\n    }\n  } else if (val && typeof val === 'object') {\n    Object.keys(val).forEach(m => {\n      f(m, loc, expr, val, path, parent, parentPropName, callback);\n    });\n  }\n};\n\nJSONPath.prototype._slice = function (loc, expr, val, path, parent, parentPropName, callback) {\n  if (!Array.isArray(val)) {\n    return undefined;\n  }\n\n  const len = val.length,\n        parts = loc.split(':'),\n        step = parts[2] && Number.parseInt(parts[2]) || 1;\n  let start = parts[0] && Number.parseInt(parts[0]) || 0,\n      end = parts[1] && Number.parseInt(parts[1]) || len;\n  start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);\n  end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);\n  const ret = [];\n\n  for (let i = start; i < end; i += step) {\n    const tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true); // Should only be possible to be an array here since first part of\n    //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\n    //     nor begin with `@` (as could return objects)\n    // This was causing excessive stack size in Node (with or\n    //  without Babel) against our performance test: `ret.push(...tmp);`\n\n\n    tmp.forEach(t => {\n      ret.push(t);\n    });\n  }\n\n  return ret;\n};\n\nJSONPath.prototype._eval = function (code, _v, _vname, path, parent, parentPropName) {\n  if (code.includes('@parentProperty')) {\n    this.currSandbox._$_parentProperty = parentPropName;\n    code = code.replace(/@parentProperty/gu, '_$_parentProperty');\n  }\n\n  if (code.includes('@parent')) {\n    this.currSandbox._$_parent = parent;\n    code = code.replace(/@parent/gu, '_$_parent');\n  }\n\n  if (code.includes('@property')) {\n    this.currSandbox._$_property = _vname;\n    code = code.replace(/@property/gu, '_$_property');\n  }\n\n  if (code.includes('@path')) {\n    this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\n    code = code.replace(/@path/gu, '_$_path');\n  }\n\n  if (code.includes('@root')) {\n    this.currSandbox._$_root = this.json;\n    code = code.replace(/@root/gu, '_$_root');\n  }\n\n  if (/@([.\\s)[])/u.test(code)) {\n    this.currSandbox._$_v = _v;\n    code = code.replace(/@([.\\s)[])/gu, '_$_v$1');\n  }\n\n  try {\n    return this.vm.runInNewContext(code, this.currSandbox);\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.log(e);\n    throw new Error('jsonPath: ' + e.message + ': ' + code);\n  }\n}; // PUBLIC CLASS PROPERTIES AND METHODS\n// Could store the cache object itself\n\n\nJSONPath.cache = {};\n/**\n * @param {string[]} pathArr Array to convert\n * @returns {string} The path string\n */\n\nJSONPath.toPathString = function (pathArr) {\n  const x = pathArr,\n        n = x.length;\n  let p = '$';\n\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += /^[0-9*]+$/u.test(x[i]) ? '[' + x[i] + ']' : \"['\" + x[i] + \"']\";\n    }\n  }\n\n  return p;\n};\n/**\n * @param {string} pointer JSON Path\n * @returns {string} JSON Pointer\n */\n\n\nJSONPath.toPointer = function (pointer) {\n  const x = pointer,\n        n = x.length;\n  let p = '';\n\n  for (let i = 1; i < n; i++) {\n    if (!/^(~|\\^|@.*?\\(\\))$/u.test(x[i])) {\n      p += '/' + x[i].toString().replace(/~/gu, '~0').replace(/\\//gu, '~1');\n    }\n  }\n\n  return p;\n};\n/**\n * @param {string} expr Expression to convert\n * @returns {string[]}\n */\n\n\nJSONPath.toPathArray = function (expr) {\n  const {\n    cache\n  } = JSONPath;\n\n  if (cache[expr]) {\n    return cache[expr].concat();\n  }\n\n  const subx = [];\n  const normalized = expr // Properties\n  .replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu, ';$&;') // Parenthetical evaluations (filtering and otherwise), directly\n  //   within brackets or single quotes\n  .replace(/[['](\\??\\(.*?\\))[\\]']/gu, function ($0, $1) {\n    return '[#' + (subx.push($1) - 1) + ']';\n  }) // Escape periods and tildes within properties\n  .replace(/\\[['\"]([^'\\]]*)['\"]\\]/gu, function ($0, prop) {\n    return \"['\" + prop.replace(/\\./gu, '%@%').replace(/~/gu, '%%@@%%') + \"']\";\n  }) // Properties operator\n  .replace(/~/gu, ';~;') // Split by property boundaries\n  .replace(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu, ';') // Reinsert periods within properties\n  .replace(/%@%/gu, '.') // Reinsert tildes within properties\n  .replace(/%%@@%%/gu, '~') // Parent\n  .replace(/(?:;)?(\\^+)(?:;)?/gu, function ($0, ups) {\n    return ';' + ups.split('').join(';') + ';';\n  }) // Descendents\n  .replace(/;;;|;;/gu, ';..;') // Remove trailing\n  .replace(/;$|'?\\]|'$/gu, '');\n  const exprList = normalized.split(';').map(function (exp) {\n    const match = exp.match(/#(\\d+)/u);\n    return !match || !match[1] ? exp : subx[match[1]];\n  });\n  cache[expr] = exprList;\n  return cache[expr].concat();\n};\n\nJSONPath.prototype.vm = vm__WEBPACK_IMPORTED_MODULE_0__;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanNvbnBhdGgtcGx1cy9kaXN0L2luZGV4LW5vZGUtZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvQjs7QUFFcEI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLFlBQVkscURBQXFEO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGNBQWM7QUFDekIsYUFBYSxjQUFjO0FBQzNCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixhQUFhLFFBQVE7QUFDckIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsMEJBQTBCO0FBQ3ZDLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUIsVUFBVSxvQkFBb0I7QUFDOUIsVUFBVSxjQUFjO0FBQ3hCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsUUFBUTtBQUNsQixVQUFVLDBCQUEwQjtBQUNwQyxVQUFVLFFBQVE7QUFDbEIsWUFBWTtBQUNaOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGNBQWMsTUFBTTtBQUNwQixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLDBEQUEwRDtBQUN4RSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsYUFBYSxXQUFXO0FBQ3RDLGNBQWMsU0FBUztBQUN2QixjQUFjLCtCQUErQjtBQUM3QyxjQUFjLGFBQWE7QUFDM0IsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxtQkFB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFIQUFxSCxHQUFHO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILG9CQUFvQixFQUFFO0FBQ3RCLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsYUFBYSx5QkFBeUIsT0FBTztBQUM3QyxHQUFHO0FBQ0gsZUFBZSxHQUFHLE9BQU8sR0FBRztBQUM1QixhQUFhO0FBQ2Isc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwrQkFBRTs7QUFFTiIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21zdGFydGVyLy4vbm9kZV9tb2R1bGVzL2pzb25wYXRoLXBsdXMvZGlzdC9pbmRleC1ub2RlLWVzbS5tanM/YzY4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdm0gZnJvbSAndm0nO1xuXG5jb25zdCB7XG4gIGhhc093blByb3BlcnR5OiBoYXNPd25Qcm9wXG59ID0gT2JqZWN0LnByb3RvdHlwZTtcbi8qKlxuKiBAdHlwZWRlZiB7bnVsbHxib29sZWFufG51bWJlcnxzdHJpbmd8UGxhaW5PYmplY3R8R2VuZXJpY0FycmF5fSBKU09OT2JqZWN0XG4qL1xuXG4vKipcbiAqIENvcGllcyBhcnJheSBhbmQgdGhlbiBwdXNoZXMgaXRlbSBpbnRvIGl0LlxuICogQHBhcmFtIHtHZW5lcmljQXJyYXl9IGFyciBBcnJheSB0byBjb3B5IGFuZCBpbnRvIHdoaWNoIHRvIHB1c2hcbiAqIEBwYXJhbSB7YW55fSBpdGVtIEFycmF5IGl0ZW0gdG8gYWRkICh0byBlbmQpXG4gKiBAcmV0dXJucyB7R2VuZXJpY0FycmF5fSBDb3B5IG9mIHRoZSBvcmlnaW5hbCBhcnJheVxuICovXG5cbmZ1bmN0aW9uIHB1c2goYXJyLCBpdGVtKSB7XG4gIGFyciA9IGFyci5zbGljZSgpO1xuICBhcnIucHVzaChpdGVtKTtcbiAgcmV0dXJuIGFycjtcbn1cbi8qKlxuICogQ29waWVzIGFycmF5IGFuZCB0aGVuIHVuc2hpZnRzIGl0ZW0gaW50byBpdC5cbiAqIEBwYXJhbSB7YW55fSBpdGVtIEFycmF5IGl0ZW0gdG8gYWRkICh0byBiZWdpbm5pbmcpXG4gKiBAcGFyYW0ge0dlbmVyaWNBcnJheX0gYXJyIEFycmF5IHRvIGNvcHkgYW5kIGludG8gd2hpY2ggdG8gdW5zaGlmdFxuICogQHJldHVybnMge0dlbmVyaWNBcnJheX0gQ29weSBvZiB0aGUgb3JpZ2luYWwgYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHVuc2hpZnQoaXRlbSwgYXJyKSB7XG4gIGFyciA9IGFyci5zbGljZSgpO1xuICBhcnIudW5zaGlmdChpdGVtKTtcbiAgcmV0dXJuIGFycjtcbn1cbi8qKlxuICogQ2F1Z2h0IHdoZW4gSlNPTlBhdGggaXMgdXNlZCB3aXRob3V0IGBuZXdgIGJ1dCByZXRocm93biBpZiB3aXRoIGBuZXdgXG4gKiBAZXh0ZW5kcyBFcnJvclxuICovXG5cblxuY2xhc3MgTmV3RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGV2YWx1YXRlZCBzY2FsYXIgdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoJ0pTT05QYXRoIHNob3VsZCBub3QgYmUgY2FsbGVkIHdpdGggXCJuZXdcIiAoaXQgcHJldmVudHMgcmV0dXJuICcgKyAnb2YgKHVud3JhcHBlZCkgc2NhbGFyIHZhbHVlcyknKTtcbiAgICB0aGlzLmF2b2lkTmV3ID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5uYW1lID0gJ05ld0Vycm9yJztcbiAgfVxuXG59XG4vKipcbiogQHR5cGVkZWYge1BsYWluT2JqZWN0fSBSZXR1cm5PYmplY3RcbiogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGhcbiogQHByb3BlcnR5IHtKU09OT2JqZWN0fSB2YWx1ZVxuKiBAcHJvcGVydHkge1BsYWluT2JqZWN0fEdlbmVyaWNBcnJheX0gcGFyZW50XG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXJlbnRQcm9wZXJ0eVxuKi9cblxuLyoqXG4qIEBjYWxsYmFjayBKU09OUGF0aENhbGxiYWNrXG4qIEBwYXJhbSB7c3RyaW5nfFBsYWluT2JqZWN0fSBwcmVmZXJyZWRPdXRwdXRcbiogQHBhcmFtIHtcInZhbHVlXCJ8XCJwcm9wZXJ0eVwifSB0eXBlXG4qIEBwYXJhbSB7UmV0dXJuT2JqZWN0fSBmdWxsUmV0T2JqXG4qIEByZXR1cm5zIHt2b2lkfVxuKi9cblxuLyoqXG4qIEBjYWxsYmFjayBPdGhlclR5cGVDYWxsYmFja1xuKiBAcGFyYW0ge0pTT05PYmplY3R9IHZhbFxuKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuKiBAcGFyYW0ge1BsYWluT2JqZWN0fEdlbmVyaWNBcnJheX0gcGFyZW50XG4qIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRQcm9wTmFtZVxuKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gLS0gQ2FuIG1ha2UgbXVsdGlsaW5lIHR5cGUgYWZ0ZXIgaHR0cHM6Ly9naXRodWIuY29tL3N5YXZvcnNreS9jb21tZW50LXBhcnNlci9pc3N1ZXMvMTA5ICovXG5cbi8qKlxuICogQHR5cGVkZWYge1BsYWluT2JqZWN0fSBKU09OUGF0aE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7SlNPTn0ganNvblxuICogQHByb3BlcnR5IHtzdHJpbmd8c3RyaW5nW119IHBhdGhcbiAqIEBwcm9wZXJ0eSB7XCJ2YWx1ZVwifFwicGF0aFwifFwicG9pbnRlclwifFwicGFyZW50XCJ8XCJwYXJlbnRQcm9wZXJ0eVwifFwiYWxsXCJ9IFtyZXN1bHRUeXBlPVwidmFsdWVcIl1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZsYXR0ZW49ZmFsc2VdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwPXRydWVdXG4gKiBAcHJvcGVydHkge1BsYWluT2JqZWN0fSBbc2FuZGJveD17fV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ByZXZlbnRFdmFsPWZhbHNlXVxuICogQHByb3BlcnR5IHtQbGFpbk9iamVjdHxHZW5lcmljQXJyYXl8bnVsbH0gW3BhcmVudD1udWxsXVxuICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3BhcmVudFByb3BlcnR5PW51bGxdXG4gKiBAcHJvcGVydHkge0pTT05QYXRoQ2FsbGJhY2t9IFtjYWxsYmFja11cbiAqIEBwcm9wZXJ0eSB7T3RoZXJUeXBlQ2FsbGJhY2t9IFtvdGhlclR5cGVDYWxsYmFja10gRGVmYXVsdHMgdG9cbiAqICAgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIG9uIGVuY291bnRlcmluZyBgQG90aGVyYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b3N0YXJ0PXRydWVdXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuIC0tIENhbiBtYWtlIG11bHRpbGluZSB0eXBlIGFmdGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9zeWF2b3Jza3kvY29tbWVudC1wYXJzZXIvaXNzdWVzLzEwOSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEpTT05QYXRoT3B0aW9uc30gb3B0cyBJZiBhIHN0cmluZywgd2lsbCBiZSB0cmVhdGVkIGFzIGBleHByYFxuICogQHBhcmFtIHtzdHJpbmd9IFtleHByXSBKU09OIHBhdGggdG8gZXZhbHVhdGVcbiAqIEBwYXJhbSB7SlNPTn0gW29ial0gSlNPTiBvYmplY3QgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICogQHBhcmFtIHtKU09OUGF0aENhbGxiYWNrfSBbY2FsbGJhY2tdIFBhc3NlZCAzIGFyZ3VtZW50czogMSkgZGVzaXJlZCBwYXlsb2FkXG4gKiAgICAgcGVyIGByZXN1bHRUeXBlYCwgMikgYFwidmFsdWVcInxcInByb3BlcnR5XCJgLCAzKSBGdWxsIHJldHVybmVkIG9iamVjdCB3aXRoXG4gKiAgICAgYWxsIHBheWxvYWRzXG4gKiBAcGFyYW0ge090aGVyVHlwZUNhbGxiYWNrfSBbb3RoZXJUeXBlQ2FsbGJhY2tdIElmIGBAb3RoZXIoKWAgaXMgYXQgdGhlIGVuZFxuICogICBvZiBvbmUncyBxdWVyeSwgdGhpcyB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGl0ZW0sIGl0c1xuICogICBwYXRoLCBpdHMgcGFyZW50LCBhbmQgaXRzIHBhcmVudCdzIHByb3BlcnR5IG5hbWUsIGFuZCBpdCBzaG91bGQgcmV0dXJuXG4gKiAgIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN1cHBsaWVkIHZhbHVlIGJlbG9uZ3MgdG8gdGhlIFwib3RoZXJcIlxuICogICB0eXBlIG9yIG5vdCAob3IgaXQgbWF5IGhhbmRsZSB0cmFuc2Zvcm1hdGlvbnMgYW5kIHJldHVybiBgZmFsc2VgKS5cbiAqIEByZXR1cm5zIHtKU09OUGF0aH1cbiAqIEBjbGFzc1xuICovXG5cblxuZnVuY3Rpb24gSlNPTlBhdGgob3B0cywgZXhwciwgb2JqLCBjYWxsYmFjaywgb3RoZXJUeXBlQ2FsbGJhY2spIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBKU09OUGF0aCkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBKU09OUGF0aChvcHRzLCBleHByLCBvYmosIGNhbGxiYWNrLCBvdGhlclR5cGVDYWxsYmFjayk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFlLmF2b2lkTmV3KSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICBvdGhlclR5cGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gb2JqO1xuICAgIG9iaiA9IGV4cHI7XG4gICAgZXhwciA9IG9wdHM7XG4gICAgb3B0cyA9IG51bGw7XG4gIH1cblxuICBjb25zdCBvcHRPYmogPSBvcHRzICYmIHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JztcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuanNvbiA9IG9wdHMuanNvbiB8fCBvYmo7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aCB8fCBleHByO1xuICB0aGlzLnJlc3VsdFR5cGUgPSBvcHRzLnJlc3VsdFR5cGUgfHwgJ3ZhbHVlJztcbiAgdGhpcy5mbGF0dGVuID0gb3B0cy5mbGF0dGVuIHx8IGZhbHNlO1xuICB0aGlzLndyYXAgPSBoYXNPd25Qcm9wLmNhbGwob3B0cywgJ3dyYXAnKSA/IG9wdHMud3JhcCA6IHRydWU7XG4gIHRoaXMuc2FuZGJveCA9IG9wdHMuc2FuZGJveCB8fCB7fTtcbiAgdGhpcy5wcmV2ZW50RXZhbCA9IG9wdHMucHJldmVudEV2YWwgfHwgZmFsc2U7XG4gIHRoaXMucGFyZW50ID0gb3B0cy5wYXJlbnQgfHwgbnVsbDtcbiAgdGhpcy5wYXJlbnRQcm9wZXJ0eSA9IG9wdHMucGFyZW50UHJvcGVydHkgfHwgbnVsbDtcbiAgdGhpcy5jYWxsYmFjayA9IG9wdHMuY2FsbGJhY2sgfHwgY2FsbGJhY2sgfHwgbnVsbDtcblxuICB0aGlzLm90aGVyVHlwZUNhbGxiYWNrID0gb3B0cy5vdGhlclR5cGVDYWxsYmFjayB8fCBvdGhlclR5cGVDYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3Qgc3VwcGx5IGFuIG90aGVyVHlwZUNhbGxiYWNrIGNhbGxiYWNrIG9wdGlvbiAnICsgJ3dpdGggdGhlIEBvdGhlcigpIG9wZXJhdG9yLicpO1xuICB9O1xuXG4gIGlmIChvcHRzLmF1dG9zdGFydCAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgcGF0aDogb3B0T2JqID8gb3B0cy5wYXRoIDogZXhwclxuICAgIH07XG5cbiAgICBpZiAoIW9wdE9iaikge1xuICAgICAgYXJncy5qc29uID0gb2JqO1xuICAgIH0gZWxzZSBpZiAoJ2pzb24nIGluIG9wdHMpIHtcbiAgICAgIGFyZ3MuanNvbiA9IG9wdHMuanNvbjtcbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSB0aGlzLmV2YWx1YXRlKGFyZ3MpO1xuXG4gICAgaWYgKCFyZXQgfHwgdHlwZW9mIHJldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBOZXdFcnJvcihyZXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cbn0gLy8gUFVCTElDIE1FVEhPRFNcblxuXG5KU09OUGF0aC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoZXhwciwganNvbiwgY2FsbGJhY2ssIG90aGVyVHlwZUNhbGxiYWNrKSB7XG4gIGxldCBjdXJyUGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICBjdXJyUGFyZW50UHJvcGVydHkgPSB0aGlzLnBhcmVudFByb3BlcnR5O1xuICBsZXQge1xuICAgIGZsYXR0ZW4sXG4gICAgd3JhcFxuICB9ID0gdGhpcztcbiAgdGhpcy5jdXJyUmVzdWx0VHlwZSA9IHRoaXMucmVzdWx0VHlwZTtcbiAgdGhpcy5jdXJyUHJldmVudEV2YWwgPSB0aGlzLnByZXZlbnRFdmFsO1xuICB0aGlzLmN1cnJTYW5kYm94ID0gdGhpcy5zYW5kYm94O1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IHRoaXMuY2FsbGJhY2s7XG4gIHRoaXMuY3Vyck90aGVyVHlwZUNhbGxiYWNrID0gb3RoZXJUeXBlQ2FsbGJhY2sgfHwgdGhpcy5vdGhlclR5cGVDYWxsYmFjaztcbiAganNvbiA9IGpzb24gfHwgdGhpcy5qc29uO1xuICBleHByID0gZXhwciB8fCB0aGlzLnBhdGg7XG5cbiAgaWYgKGV4cHIgJiYgdHlwZW9mIGV4cHIgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGV4cHIpKSB7XG4gICAgaWYgKCFleHByLnBhdGggJiYgZXhwci5wYXRoICE9PSAnJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3Qgc3VwcGx5IGEgXCJwYXRoXCIgcHJvcGVydHkgd2hlbiBwcm92aWRpbmcgYW4gb2JqZWN0ICcgKyAnYXJndW1lbnQgdG8gSlNPTlBhdGguZXZhbHVhdGUoKS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc093blByb3AuY2FsbChleHByLCAnanNvbicpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYSBcImpzb25cIiBwcm9wZXJ0eSB3aGVuIHByb3ZpZGluZyBhbiBvYmplY3QgJyArICdhcmd1bWVudCB0byBKU09OUGF0aC5ldmFsdWF0ZSgpLicpO1xuICAgIH1cblxuICAgICh7XG4gICAgICBqc29uXG4gICAgfSA9IGV4cHIpO1xuICAgIGZsYXR0ZW4gPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ2ZsYXR0ZW4nKSA/IGV4cHIuZmxhdHRlbiA6IGZsYXR0ZW47XG4gICAgdGhpcy5jdXJyUmVzdWx0VHlwZSA9IGhhc093blByb3AuY2FsbChleHByLCAncmVzdWx0VHlwZScpID8gZXhwci5yZXN1bHRUeXBlIDogdGhpcy5jdXJyUmVzdWx0VHlwZTtcbiAgICB0aGlzLmN1cnJTYW5kYm94ID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdzYW5kYm94JykgPyBleHByLnNhbmRib3ggOiB0aGlzLmN1cnJTYW5kYm94O1xuICAgIHdyYXAgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ3dyYXAnKSA/IGV4cHIud3JhcCA6IHdyYXA7XG4gICAgdGhpcy5jdXJyUHJldmVudEV2YWwgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ3ByZXZlbnRFdmFsJykgPyBleHByLnByZXZlbnRFdmFsIDogdGhpcy5jdXJyUHJldmVudEV2YWw7XG4gICAgY2FsbGJhY2sgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ2NhbGxiYWNrJykgPyBleHByLmNhbGxiYWNrIDogY2FsbGJhY2s7XG4gICAgdGhpcy5jdXJyT3RoZXJUeXBlQ2FsbGJhY2sgPSBoYXNPd25Qcm9wLmNhbGwoZXhwciwgJ290aGVyVHlwZUNhbGxiYWNrJykgPyBleHByLm90aGVyVHlwZUNhbGxiYWNrIDogdGhpcy5jdXJyT3RoZXJUeXBlQ2FsbGJhY2s7XG4gICAgY3VyclBhcmVudCA9IGhhc093blByb3AuY2FsbChleHByLCAncGFyZW50JykgPyBleHByLnBhcmVudCA6IGN1cnJQYXJlbnQ7XG4gICAgY3VyclBhcmVudFByb3BlcnR5ID0gaGFzT3duUHJvcC5jYWxsKGV4cHIsICdwYXJlbnRQcm9wZXJ0eScpID8gZXhwci5wYXJlbnRQcm9wZXJ0eSA6IGN1cnJQYXJlbnRQcm9wZXJ0eTtcbiAgICBleHByID0gZXhwci5wYXRoO1xuICB9XG5cbiAgY3VyclBhcmVudCA9IGN1cnJQYXJlbnQgfHwgbnVsbDtcbiAgY3VyclBhcmVudFByb3BlcnR5ID0gY3VyclBhcmVudFByb3BlcnR5IHx8IG51bGw7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwcikpIHtcbiAgICBleHByID0gSlNPTlBhdGgudG9QYXRoU3RyaW5nKGV4cHIpO1xuICB9XG5cbiAgaWYgKCFleHByICYmIGV4cHIgIT09ICcnIHx8ICFqc29uKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGV4cHJMaXN0ID0gSlNPTlBhdGgudG9QYXRoQXJyYXkoZXhwcik7XG5cbiAgaWYgKGV4cHJMaXN0WzBdID09PSAnJCcgJiYgZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgIGV4cHJMaXN0LnNoaWZ0KCk7XG4gIH1cblxuICB0aGlzLl9oYXNQYXJlbnRTZWxlY3RvciA9IG51bGw7XG5cbiAgY29uc3QgcmVzdWx0ID0gdGhpcy5fdHJhY2UoZXhwckxpc3QsIGpzb24sIFsnJCddLCBjdXJyUGFyZW50LCBjdXJyUGFyZW50UHJvcGVydHksIGNhbGxiYWNrKS5maWx0ZXIoZnVuY3Rpb24gKGVhKSB7XG4gICAgcmV0dXJuIGVhICYmICFlYS5pc1BhcmVudFNlbGVjdG9yO1xuICB9KTtcblxuICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gd3JhcCA/IFtdIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCF3cmFwICYmIHJlc3VsdC5sZW5ndGggPT09IDEgJiYgIXJlc3VsdFswXS5oYXNBcnJFeHByKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFByZWZlcnJlZE91dHB1dChyZXN1bHRbMF0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKHJzbHQsIGVhKSA9PiB7XG4gICAgY29uc3QgdmFsT3JQYXRoID0gdGhpcy5fZ2V0UHJlZmVycmVkT3V0cHV0KGVhKTtcblxuICAgIGlmIChmbGF0dGVuICYmIEFycmF5LmlzQXJyYXkodmFsT3JQYXRoKSkge1xuICAgICAgcnNsdCA9IHJzbHQuY29uY2F0KHZhbE9yUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzbHQucHVzaCh2YWxPclBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiByc2x0O1xuICB9LCBbXSk7XG59OyAvLyBQUklWQVRFIE1FVEhPRFNcblxuXG5KU09OUGF0aC5wcm90b3R5cGUuX2dldFByZWZlcnJlZE91dHB1dCA9IGZ1bmN0aW9uIChlYSkge1xuICBjb25zdCByZXN1bHRUeXBlID0gdGhpcy5jdXJyUmVzdWx0VHlwZTtcblxuICBzd2l0Y2ggKHJlc3VsdFR5cGUpIHtcbiAgICBjYXNlICdhbGwnOlxuICAgICAge1xuICAgICAgICBjb25zdCBwYXRoID0gQXJyYXkuaXNBcnJheShlYS5wYXRoKSA/IGVhLnBhdGggOiBKU09OUGF0aC50b1BhdGhBcnJheShlYS5wYXRoKTtcbiAgICAgICAgZWEucG9pbnRlciA9IEpTT05QYXRoLnRvUG9pbnRlcihwYXRoKTtcbiAgICAgICAgZWEucGF0aCA9IHR5cGVvZiBlYS5wYXRoID09PSAnc3RyaW5nJyA/IGVhLnBhdGggOiBKU09OUGF0aC50b1BhdGhTdHJpbmcoZWEucGF0aCk7XG4gICAgICAgIHJldHVybiBlYTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICBjYXNlICdwYXJlbnQnOlxuICAgIGNhc2UgJ3BhcmVudFByb3BlcnR5JzpcbiAgICAgIHJldHVybiBlYVtyZXN1bHRUeXBlXTtcblxuICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgcmV0dXJuIEpTT05QYXRoLnRvUGF0aFN0cmluZyhlYVtyZXN1bHRUeXBlXSk7XG5cbiAgICBjYXNlICdwb2ludGVyJzpcbiAgICAgIHJldHVybiBKU09OUGF0aC50b1BvaW50ZXIoZWEucGF0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biByZXN1bHQgdHlwZScpO1xuICB9XG59O1xuXG5KU09OUGF0aC5wcm90b3R5cGUuX2hhbmRsZUNhbGxiYWNrID0gZnVuY3Rpb24gKGZ1bGxSZXRPYmosIGNhbGxiYWNrLCB0eXBlKSB7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIGNvbnN0IHByZWZlcnJlZE91dHB1dCA9IHRoaXMuX2dldFByZWZlcnJlZE91dHB1dChmdWxsUmV0T2JqKTtcblxuICAgIGZ1bGxSZXRPYmoucGF0aCA9IHR5cGVvZiBmdWxsUmV0T2JqLnBhdGggPT09ICdzdHJpbmcnID8gZnVsbFJldE9iai5wYXRoIDogSlNPTlBhdGgudG9QYXRoU3RyaW5nKGZ1bGxSZXRPYmoucGF0aCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuXG4gICAgY2FsbGJhY2socHJlZmVycmVkT3V0cHV0LCB0eXBlLCBmdWxsUmV0T2JqKTtcbiAgfVxufTtcbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByXG4gKiBAcGFyYW0ge0pTT05PYmplY3R9IHZhbFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7UGxhaW5PYmplY3R8R2VuZXJpY0FycmF5fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRQcm9wTmFtZVxuICogQHBhcmFtIHtKU09OUGF0aENhbGxiYWNrfSBjYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFufSBoYXNBcnJFeHByXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxpdGVyYWxQcmlvcml0eVxuICogQHJldHVybnMge1JldHVybk9iamVjdHxSZXR1cm5PYmplY3RbXX1cbiAqL1xuXG5cbkpTT05QYXRoLnByb3RvdHlwZS5fdHJhY2UgPSBmdW5jdGlvbiAoZXhwciwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgaGFzQXJyRXhwciwgbGl0ZXJhbFByaW9yaXR5KSB7XG4gIC8vIE5vIGV4cHIgdG8gZm9sbG93PyByZXR1cm4gcGF0aCBhbmQgdmFsdWUgYXMgdGhlIHJlc3VsdCBvZlxuICAvLyAgdGhpcyB0cmFjZSBicmFuY2hcbiAgbGV0IHJldE9iajtcblxuICBpZiAoIWV4cHIubGVuZ3RoKSB7XG4gICAgcmV0T2JqID0ge1xuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlOiB2YWwsXG4gICAgICBwYXJlbnQsXG4gICAgICBwYXJlbnRQcm9wZXJ0eTogcGFyZW50UHJvcE5hbWUsXG4gICAgICBoYXNBcnJFeHByXG4gICAgfTtcblxuICAgIHRoaXMuX2hhbmRsZUNhbGxiYWNrKHJldE9iaiwgY2FsbGJhY2ssICd2YWx1ZScpO1xuXG4gICAgcmV0dXJuIHJldE9iajtcbiAgfVxuXG4gIGNvbnN0IGxvYyA9IGV4cHJbMF0sXG4gICAgICAgIHggPSBleHByLnNsaWNlKDEpOyAvLyBXZSBuZWVkIHRvIGdhdGhlciB0aGUgcmV0dXJuIHZhbHVlIG9mIHJlY3Vyc2l2ZSB0cmFjZSBjYWxscyBpbiBvcmRlciB0b1xuICAvLyBkbyB0aGUgcGFyZW50IHNlbCBjb21wdXRhdGlvbi5cblxuICBjb25zdCByZXQgPSBbXTtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7UmV0dXJuT2JqZWN0fFJldHVybk9iamVjdFtdfSBlbGVtc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkUmV0KGVsZW1zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbXMpKSB7XG4gICAgICAvLyBUaGlzIHdhcyBjYXVzaW5nIGV4Y2Vzc2l2ZSBzdGFjayBzaXplIGluIE5vZGUgKHdpdGggb3JcbiAgICAgIC8vICB3aXRob3V0IEJhYmVsKSBhZ2FpbnN0IG91ciBwZXJmb3JtYW5jZSB0ZXN0OlxuICAgICAgLy8gIGByZXQucHVzaCguLi5lbGVtcyk7YFxuICAgICAgZWxlbXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgcmV0LnB1c2godCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goZWxlbXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICgodHlwZW9mIGxvYyAhPT0gJ3N0cmluZycgfHwgbGl0ZXJhbFByaW9yaXR5KSAmJiB2YWwgJiYgaGFzT3duUHJvcC5jYWxsKHZhbCwgbG9jKSkge1xuICAgIC8vIHNpbXBsZSBjYXNlLS1kaXJlY3RseSBmb2xsb3cgcHJvcGVydHlcbiAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsW2xvY10sIHB1c2gocGF0aCwgbG9jKSwgdmFsLCBsb2MsIGNhbGxiYWNrLCBoYXNBcnJFeHByKSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1zd2l0Y2ggLS0gUGFydCBvZiBsYXJnZXIgYGlmYFxuICB9IGVsc2UgaWYgKGxvYyA9PT0gJyonKSB7XG4gICAgLy8gYWxsIGNoaWxkIHByb3BlcnRpZXNcbiAgICB0aGlzLl93YWxrKGxvYywgeCwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgKG0sIGwsIF94LCB2LCBwLCBwYXIsIHByLCBjYikgPT4ge1xuICAgICAgYWRkUmV0KHRoaXMuX3RyYWNlKHVuc2hpZnQobSwgX3gpLCB2LCBwLCBwYXIsIHByLCBjYiwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGxvYyA9PT0gJy4uJykge1xuICAgIC8vIGFsbCBkZXNjZW5kZW50IHBhcmVudCBwcm9wZXJ0aWVzXG4gICAgLy8gQ2hlY2sgcmVtYWluaW5nIGV4cHJlc3Npb24gd2l0aCB2YWwncyBpbW1lZGlhdGUgY2hpbGRyZW5cbiAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgaGFzQXJyRXhwcikpO1xuXG4gICAgdGhpcy5fd2Fsayhsb2MsIHgsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIChtLCBsLCBfeCwgdiwgcCwgcGFyLCBwciwgY2IpID0+IHtcbiAgICAgIC8vIFdlIGRvbid0IGpvaW4gbSBhbmQgeCBoZXJlIGJlY2F1c2Ugd2Ugb25seSB3YW50IHBhcmVudHMsXG4gICAgICAvLyAgIG5vdCBzY2FsYXIgdmFsdWVzXG4gICAgICBpZiAodHlwZW9mIHZbbV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIEtlZXAgZ29pbmcgd2l0aCByZWN1cnNpdmUgZGVzY2VudCBvbiB2YWwnc1xuICAgICAgICAvLyAgIG9iamVjdCBjaGlsZHJlblxuICAgICAgICBhZGRSZXQodGhpcy5fdHJhY2UodW5zaGlmdChsLCBfeCksIHZbbV0sIHB1c2gocCwgbSksIHYsIG0sIGNiLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfSk7IC8vIFRoZSBwYXJlbnQgc2VsIGNvbXB1dGF0aW9uIGlzIGhhbmRsZWQgaW4gdGhlIGZyYW1lIGFib3ZlIHVzaW5nIHRoZVxuICAgIC8vIGFuY2VzdG9yIG9iamVjdCBvZiB2YWxcblxuICB9IGVsc2UgaWYgKGxvYyA9PT0gJ14nKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYSBmaW5hbCBlbmRwb2ludCwgc28gd2UgZG8gbm90IGludm9rZSB0aGUgY2FsbGJhY2sgaGVyZVxuICAgIHRoaXMuX2hhc1BhcmVudFNlbGVjdG9yID0gdHJ1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aC5zbGljZSgwLCAtMSksXG4gICAgICBleHByOiB4LFxuICAgICAgaXNQYXJlbnRTZWxlY3RvcjogdHJ1ZVxuICAgIH07XG4gIH0gZWxzZSBpZiAobG9jID09PSAnficpIHtcbiAgICAvLyBwcm9wZXJ0eSBuYW1lXG4gICAgcmV0T2JqID0ge1xuICAgICAgcGF0aDogcHVzaChwYXRoLCBsb2MpLFxuICAgICAgdmFsdWU6IHBhcmVudFByb3BOYW1lLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50UHJvcGVydHk6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5faGFuZGxlQ2FsbGJhY2socmV0T2JqLCBjYWxsYmFjaywgJ3Byb3BlcnR5Jyk7XG5cbiAgICByZXR1cm4gcmV0T2JqO1xuICB9IGVsc2UgaWYgKGxvYyA9PT0gJyQnKSB7XG4gICAgLy8gcm9vdCBvbmx5XG4gICAgYWRkUmV0KHRoaXMuX3RyYWNlKHgsIHZhbCwgcGF0aCwgbnVsbCwgbnVsbCwgY2FsbGJhY2ssIGhhc0FyckV4cHIpKTtcbiAgfSBlbHNlIGlmICgvXigtP1xcZCopOigtP1xcZCopOj8oXFxkKikkL3UudGVzdChsb2MpKSB7XG4gICAgLy8gW3N0YXJ0OmVuZDpzdGVwXSAgUHl0aG9uIHNsaWNlIHN5bnRheFxuICAgIGFkZFJldCh0aGlzLl9zbGljZShsb2MsIHgsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2spKTtcbiAgfSBlbHNlIGlmIChsb2MuaW5kZXhPZignPygnKSA9PT0gMCkge1xuICAgIC8vIFs/KGV4cHIpXSAoZmlsdGVyaW5nKVxuICAgIGlmICh0aGlzLmN1cnJQcmV2ZW50RXZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmFsIFs/KGV4cHIpXSBwcmV2ZW50ZWQgaW4gSlNPTlBhdGggZXhwcmVzc2lvbi4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl93YWxrKGxvYywgeCwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgKG0sIGwsIF94LCB2LCBwLCBwYXIsIHByLCBjYikgPT4ge1xuICAgICAgaWYgKHRoaXMuX2V2YWwobC5yZXBsYWNlKC9eXFw/XFwoKC4qPylcXCkkL3UsICckMScpLCB2W21dLCBtLCBwLCBwYXIsIHByKSkge1xuICAgICAgICBhZGRSZXQodGhpcy5fdHJhY2UodW5zaGlmdChtLCBfeCksIHYsIHAsIHBhciwgcHIsIGNiLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobG9jWzBdID09PSAnKCcpIHtcbiAgICAvLyBbKGV4cHIpXSAoZHluYW1pYyBwcm9wZXJ0eS9pbmRleClcbiAgICBpZiAodGhpcy5jdXJyUHJldmVudEV2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXZhbCBbKGV4cHIpXSBwcmV2ZW50ZWQgaW4gSlNPTlBhdGggZXhwcmVzc2lvbi4nKTtcbiAgICB9IC8vIEFzIHRoaXMgd2lsbCByZXNvbHZlIHRvIGEgcHJvcGVydHkgbmFtZSAoYnV0IHdlIGRvbid0IGtub3cgaXRcbiAgICAvLyAgeWV0KSwgcHJvcGVydHkgYW5kIHBhcmVudCBpbmZvcm1hdGlvbiBpcyByZWxhdGl2ZSB0byB0aGVcbiAgICAvLyAgcGFyZW50IG9mIHRoZSBwcm9wZXJ0eSB0byB3aGljaCB0aGlzIGV4cHJlc3Npb24gd2lsbCByZXNvbHZlXG5cblxuICAgIGFkZFJldCh0aGlzLl90cmFjZSh1bnNoaWZ0KHRoaXMuX2V2YWwobG9jLCB2YWwsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aC5zbGljZSgwLCAtMSksIHBhcmVudCwgcGFyZW50UHJvcE5hbWUpLCB4KSwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgaGFzQXJyRXhwcikpO1xuICB9IGVsc2UgaWYgKGxvY1swXSA9PT0gJ0AnKSB7XG4gICAgLy8gdmFsdWUgdHlwZTogQGJvb2xlYW4oKSwgZXRjLlxuICAgIGxldCBhZGRUeXBlID0gZmFsc2U7XG4gICAgY29uc3QgdmFsdWVUeXBlID0gbG9jLnNsaWNlKDEsIC0yKTtcblxuICAgIHN3aXRjaCAodmFsdWVUeXBlKSB7XG4gICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBpZiAoIXZhbCB8fCAhWydvYmplY3QnLCAnZnVuY3Rpb24nXS5pbmNsdWRlcyh0eXBlb2YgdmFsKSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IHZhbHVlVHlwZSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbCkgJiYgISh2YWwgJSAxKSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsKSkge1xuICAgICAgICAgIGFkZFR5cGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ25vbkZpbml0ZSc6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgICBhZGRUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gdmFsdWVUeXBlKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb3RoZXInOlxuICAgICAgICBhZGRUeXBlID0gdGhpcy5jdXJyT3RoZXJUeXBlQ2FsbGJhY2sodmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgYWRkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biB2YWx1ZSB0eXBlICcgKyB2YWx1ZVR5cGUpO1xuICAgIH1cblxuICAgIGlmIChhZGRUeXBlKSB7XG4gICAgICByZXRPYmogPSB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGFyZW50UHJvcGVydHk6IHBhcmVudFByb3BOYW1lXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9oYW5kbGVDYWxsYmFjayhyZXRPYmosIGNhbGxiYWNrLCAndmFsdWUnKTtcblxuICAgICAgcmV0dXJuIHJldE9iajtcbiAgICB9IC8vIGAtZXNjYXBlZCBwcm9wZXJ0eVxuXG4gIH0gZWxzZSBpZiAobG9jWzBdID09PSAnYCcgJiYgdmFsICYmIGhhc093blByb3AuY2FsbCh2YWwsIGxvYy5zbGljZSgxKSkpIHtcbiAgICBjb25zdCBsb2NQcm9wID0gbG9jLnNsaWNlKDEpO1xuICAgIGFkZFJldCh0aGlzLl90cmFjZSh4LCB2YWxbbG9jUHJvcF0sIHB1c2gocGF0aCwgbG9jUHJvcCksIHZhbCwgbG9jUHJvcCwgY2FsbGJhY2ssIGhhc0FyckV4cHIsIHRydWUpKTtcbiAgfSBlbHNlIGlmIChsb2MuaW5jbHVkZXMoJywnKSkge1xuICAgIC8vIFtuYW1lMSxuYW1lMiwuLi5dXG4gICAgY29uc3QgcGFydHMgPSBsb2Muc3BsaXQoJywnKTtcblxuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgYWRkUmV0KHRoaXMuX3RyYWNlKHVuc2hpZnQocGFydCwgeCksIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIHRydWUpKTtcbiAgICB9IC8vIHNpbXBsZSBjYXNlLS1kaXJlY3RseSBmb2xsb3cgcHJvcGVydHlcblxuICB9IGVsc2UgaWYgKCFsaXRlcmFsUHJpb3JpdHkgJiYgdmFsICYmIGhhc093blByb3AuY2FsbCh2YWwsIGxvYykpIHtcbiAgICBhZGRSZXQodGhpcy5fdHJhY2UoeCwgdmFsW2xvY10sIHB1c2gocGF0aCwgbG9jKSwgdmFsLCBsb2MsIGNhbGxiYWNrLCBoYXNBcnJFeHByLCB0cnVlKSk7XG4gIH0gLy8gV2UgY2hlY2sgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZm9yIHBhcmVudCBzZWxlY3Rpb25zLiBGb3IgcGFyZW50XG4gIC8vIHNlbGVjdGlvbnMgd2UgZGlzY2FyZCB0aGUgdmFsdWUgb2JqZWN0IGFuZCBjb250aW51ZSB0aGUgdHJhY2Ugd2l0aCB0aGVcbiAgLy8gY3VycmVudCB2YWwgb2JqZWN0XG5cblxuICBpZiAodGhpcy5faGFzUGFyZW50U2VsZWN0b3IpIHtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHJldC5sZW5ndGg7IHQrKykge1xuICAgICAgY29uc3QgcmV0dCA9IHJldFt0XTtcblxuICAgICAgaWYgKHJldHQgJiYgcmV0dC5pc1BhcmVudFNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHRoaXMuX3RyYWNlKHJldHQuZXhwciwgdmFsLCByZXR0LnBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrLCBoYXNBcnJFeHByKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0bXApKSB7XG4gICAgICAgICAgcmV0W3RdID0gdG1wWzBdO1xuICAgICAgICAgIGNvbnN0IHRsID0gdG1wLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAobGV0IHR0ID0gMTsgdHQgPCB0bDsgdHQrKykge1xuICAgICAgICAgICAgdCsrO1xuICAgICAgICAgICAgcmV0LnNwbGljZSh0LCAwLCB0bXBbdHRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0W3RdID0gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbkpTT05QYXRoLnByb3RvdHlwZS5fd2FsayA9IGZ1bmN0aW9uIChsb2MsIGV4cHIsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2ssIGYpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNvbnN0IG4gPSB2YWwubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGYoaSwgbG9jLCBleHByLCB2YWwsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgT2JqZWN0LmtleXModmFsKS5mb3JFYWNoKG0gPT4ge1xuICAgICAgZihtLCBsb2MsIGV4cHIsIHZhbCwgcGF0aCwgcGFyZW50LCBwYXJlbnRQcm9wTmFtZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG59O1xuXG5KU09OUGF0aC5wcm90b3R5cGUuX3NsaWNlID0gZnVuY3Rpb24gKGxvYywgZXhwciwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBsZW4gPSB2YWwubGVuZ3RoLFxuICAgICAgICBwYXJ0cyA9IGxvYy5zcGxpdCgnOicpLFxuICAgICAgICBzdGVwID0gcGFydHNbMl0gJiYgTnVtYmVyLnBhcnNlSW50KHBhcnRzWzJdKSB8fCAxO1xuICBsZXQgc3RhcnQgPSBwYXJ0c1swXSAmJiBOdW1iZXIucGFyc2VJbnQocGFydHNbMF0pIHx8IDAsXG4gICAgICBlbmQgPSBwYXJ0c1sxXSAmJiBOdW1iZXIucGFyc2VJbnQocGFydHNbMV0pIHx8IGxlbjtcbiAgc3RhcnQgPSBzdGFydCA8IDAgPyBNYXRoLm1heCgwLCBzdGFydCArIGxlbikgOiBNYXRoLm1pbihsZW4sIHN0YXJ0KTtcbiAgZW5kID0gZW5kIDwgMCA/IE1hdGgubWF4KDAsIGVuZCArIGxlbikgOiBNYXRoLm1pbihsZW4sIGVuZCk7XG4gIGNvbnN0IHJldCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBzdGVwKSB7XG4gICAgY29uc3QgdG1wID0gdGhpcy5fdHJhY2UodW5zaGlmdChpLCBleHByKSwgdmFsLCBwYXRoLCBwYXJlbnQsIHBhcmVudFByb3BOYW1lLCBjYWxsYmFjaywgdHJ1ZSk7IC8vIFNob3VsZCBvbmx5IGJlIHBvc3NpYmxlIHRvIGJlIGFuIGFycmF5IGhlcmUgc2luY2UgZmlyc3QgcGFydCBvZlxuICAgIC8vICAgYGB1bnNoaWZ0KGksIGV4cHIpYCBwYXNzZWQgaW4gYWJvdmUgd291bGQgbm90IGJlIGVtcHR5LCBub3IgYH5gLFxuICAgIC8vICAgICBub3IgYmVnaW4gd2l0aCBgQGAgKGFzIGNvdWxkIHJldHVybiBvYmplY3RzKVxuICAgIC8vIFRoaXMgd2FzIGNhdXNpbmcgZXhjZXNzaXZlIHN0YWNrIHNpemUgaW4gTm9kZSAod2l0aCBvclxuICAgIC8vICB3aXRob3V0IEJhYmVsKSBhZ2FpbnN0IG91ciBwZXJmb3JtYW5jZSB0ZXN0OiBgcmV0LnB1c2goLi4udG1wKTtgXG5cblxuICAgIHRtcC5mb3JFYWNoKHQgPT4ge1xuICAgICAgcmV0LnB1c2godCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuSlNPTlBhdGgucHJvdG90eXBlLl9ldmFsID0gZnVuY3Rpb24gKGNvZGUsIF92LCBfdm5hbWUsIHBhdGgsIHBhcmVudCwgcGFyZW50UHJvcE5hbWUpIHtcbiAgaWYgKGNvZGUuaW5jbHVkZXMoJ0BwYXJlbnRQcm9wZXJ0eScpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9wYXJlbnRQcm9wZXJ0eSA9IHBhcmVudFByb3BOYW1lO1xuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL0BwYXJlbnRQcm9wZXJ0eS9ndSwgJ18kX3BhcmVudFByb3BlcnR5Jyk7XG4gIH1cblxuICBpZiAoY29kZS5pbmNsdWRlcygnQHBhcmVudCcpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgY29kZSA9IGNvZGUucmVwbGFjZSgvQHBhcmVudC9ndSwgJ18kX3BhcmVudCcpO1xuICB9XG5cbiAgaWYgKGNvZGUuaW5jbHVkZXMoJ0Bwcm9wZXJ0eScpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9wcm9wZXJ0eSA9IF92bmFtZTtcbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9AcHJvcGVydHkvZ3UsICdfJF9wcm9wZXJ0eScpO1xuICB9XG5cbiAgaWYgKGNvZGUuaW5jbHVkZXMoJ0BwYXRoJykpIHtcbiAgICB0aGlzLmN1cnJTYW5kYm94Ll8kX3BhdGggPSBKU09OUGF0aC50b1BhdGhTdHJpbmcocGF0aC5jb25jYXQoW192bmFtZV0pKTtcbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9AcGF0aC9ndSwgJ18kX3BhdGgnKTtcbiAgfVxuXG4gIGlmIChjb2RlLmluY2x1ZGVzKCdAcm9vdCcpKSB7XG4gICAgdGhpcy5jdXJyU2FuZGJveC5fJF9yb290ID0gdGhpcy5qc29uO1xuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL0Byb290L2d1LCAnXyRfcm9vdCcpO1xuICB9XG5cbiAgaWYgKC9AKFsuXFxzKVtdKS91LnRlc3QoY29kZSkpIHtcbiAgICB0aGlzLmN1cnJTYW5kYm94Ll8kX3YgPSBfdjtcbiAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9AKFsuXFxzKVtdKS9ndSwgJ18kX3YkMScpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy52bS5ydW5Jbk5ld0NvbnRleHQoY29kZSwgdGhpcy5jdXJyU2FuZGJveCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIHRocm93IG5ldyBFcnJvcignanNvblBhdGg6ICcgKyBlLm1lc3NhZ2UgKyAnOiAnICsgY29kZSk7XG4gIH1cbn07IC8vIFBVQkxJQyBDTEFTUyBQUk9QRVJUSUVTIEFORCBNRVRIT0RTXG4vLyBDb3VsZCBzdG9yZSB0aGUgY2FjaGUgb2JqZWN0IGl0c2VsZlxuXG5cbkpTT05QYXRoLmNhY2hlID0ge307XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhBcnIgQXJyYXkgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggc3RyaW5nXG4gKi9cblxuSlNPTlBhdGgudG9QYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhBcnIpIHtcbiAgY29uc3QgeCA9IHBhdGhBcnIsXG4gICAgICAgIG4gPSB4Lmxlbmd0aDtcbiAgbGV0IHAgPSAnJCc7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoIS9eKH58XFxefEAuKj9cXChcXCkpJC91LnRlc3QoeFtpXSkpIHtcbiAgICAgIHAgKz0gL15bMC05Kl0rJC91LnRlc3QoeFtpXSkgPyAnWycgKyB4W2ldICsgJ10nIDogXCJbJ1wiICsgeFtpXSArIFwiJ11cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcDtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2ludGVyIEpTT04gUGF0aFxuICogQHJldHVybnMge3N0cmluZ30gSlNPTiBQb2ludGVyXG4gKi9cblxuXG5KU09OUGF0aC50b1BvaW50ZXIgPSBmdW5jdGlvbiAocG9pbnRlcikge1xuICBjb25zdCB4ID0gcG9pbnRlcixcbiAgICAgICAgbiA9IHgubGVuZ3RoO1xuICBsZXQgcCA9ICcnO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKCEvXih+fFxcXnxALio/XFwoXFwpKSQvdS50ZXN0KHhbaV0pKSB7XG4gICAgICBwICs9ICcvJyArIHhbaV0udG9TdHJpbmcoKS5yZXBsYWNlKC9+L2d1LCAnfjAnKS5yZXBsYWNlKC9cXC8vZ3UsICd+MScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHIgRXhwcmVzc2lvbiB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cblxuXG5KU09OUGF0aC50b1BhdGhBcnJheSA9IGZ1bmN0aW9uIChleHByKSB7XG4gIGNvbnN0IHtcbiAgICBjYWNoZVxuICB9ID0gSlNPTlBhdGg7XG5cbiAgaWYgKGNhY2hlW2V4cHJdKSB7XG4gICAgcmV0dXJuIGNhY2hlW2V4cHJdLmNvbmNhdCgpO1xuICB9XG5cbiAgY29uc3Qgc3VieCA9IFtdO1xuICBjb25zdCBub3JtYWxpemVkID0gZXhwciAvLyBQcm9wZXJ0aWVzXG4gIC5yZXBsYWNlKC9AKD86bnVsbHxib29sZWFufG51bWJlcnxzdHJpbmd8aW50ZWdlcnx1bmRlZmluZWR8bm9uRmluaXRlfHNjYWxhcnxhcnJheXxvYmplY3R8ZnVuY3Rpb258b3RoZXIpXFwoXFwpL2d1LCAnOyQmOycpIC8vIFBhcmVudGhldGljYWwgZXZhbHVhdGlvbnMgKGZpbHRlcmluZyBhbmQgb3RoZXJ3aXNlKSwgZGlyZWN0bHlcbiAgLy8gICB3aXRoaW4gYnJhY2tldHMgb3Igc2luZ2xlIHF1b3Rlc1xuICAucmVwbGFjZSgvW1snXShcXD8/XFwoLio/XFwpKVtcXF0nXS9ndSwgZnVuY3Rpb24gKCQwLCAkMSkge1xuICAgIHJldHVybiAnWyMnICsgKHN1YngucHVzaCgkMSkgLSAxKSArICddJztcbiAgfSkgLy8gRXNjYXBlIHBlcmlvZHMgYW5kIHRpbGRlcyB3aXRoaW4gcHJvcGVydGllc1xuICAucmVwbGFjZSgvXFxbWydcIl0oW14nXFxdXSopWydcIl1cXF0vZ3UsIGZ1bmN0aW9uICgkMCwgcHJvcCkge1xuICAgIHJldHVybiBcIlsnXCIgKyBwcm9wLnJlcGxhY2UoL1xcLi9ndSwgJyVAJScpLnJlcGxhY2UoL34vZ3UsICclJUBAJSUnKSArIFwiJ11cIjtcbiAgfSkgLy8gUHJvcGVydGllcyBvcGVyYXRvclxuICAucmVwbGFjZSgvfi9ndSwgJzt+OycpIC8vIFNwbGl0IGJ5IHByb3BlcnR5IGJvdW5kYXJpZXNcbiAgLnJlcGxhY2UoL1snXCJdP1xcLlsnXCJdPyg/IVteW10qXFxdKXxcXFtbJ1wiXT8vZ3UsICc7JykgLy8gUmVpbnNlcnQgcGVyaW9kcyB3aXRoaW4gcHJvcGVydGllc1xuICAucmVwbGFjZSgvJUAlL2d1LCAnLicpIC8vIFJlaW5zZXJ0IHRpbGRlcyB3aXRoaW4gcHJvcGVydGllc1xuICAucmVwbGFjZSgvJSVAQCUlL2d1LCAnficpIC8vIFBhcmVudFxuICAucmVwbGFjZSgvKD86Oyk/KFxcXispKD86Oyk/L2d1LCBmdW5jdGlvbiAoJDAsIHVwcykge1xuICAgIHJldHVybiAnOycgKyB1cHMuc3BsaXQoJycpLmpvaW4oJzsnKSArICc7JztcbiAgfSkgLy8gRGVzY2VuZGVudHNcbiAgLnJlcGxhY2UoLzs7O3w7Oy9ndSwgJzsuLjsnKSAvLyBSZW1vdmUgdHJhaWxpbmdcbiAgLnJlcGxhY2UoLzskfCc/XFxdfCckL2d1LCAnJyk7XG4gIGNvbnN0IGV4cHJMaXN0ID0gbm9ybWFsaXplZC5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoZXhwKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBleHAubWF0Y2goLyMoXFxkKykvdSk7XG4gICAgcmV0dXJuICFtYXRjaCB8fCAhbWF0Y2hbMV0gPyBleHAgOiBzdWJ4W21hdGNoWzFdXTtcbiAgfSk7XG4gIGNhY2hlW2V4cHJdID0gZXhwckxpc3Q7XG4gIHJldHVybiBjYWNoZVtleHByXS5jb25jYXQoKTtcbn07XG5cbkpTT05QYXRoLnByb3RvdHlwZS52bSA9IHZtO1xuXG5leHBvcnQgeyBKU09OUGF0aCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jsonpath-plus/dist/index-node-esm.mjs\n");

/***/ })

};
;